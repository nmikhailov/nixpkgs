<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 20. Troubleshooting</title><link rel="stylesheet" type="text/css" href="style.css" /><link rel="stylesheet" type="text/css" href="highlight/github.css" /><script src="highlight/highlight.pack.js" type="text/javascript"></script><script src="highlight/init.js" type="text/javascript"></script><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="NixOS Manual" /><link rel="up" href="ch-running.html" title="Part III. Administration" /><link rel="prev" href="ch-containers.html" title="Chapter 19. Container Management" /><link rel="next" href="ch-development.html" title="Part IV. Development" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 20. Troubleshooting</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch-containers.html">Prev</a> </td><th width="60%" align="center">Part III. Administration</th><td width="20%" align="right"> <a accesskey="n" href="ch-development.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch-troubleshooting"></a>Chapter 20. Troubleshooting</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="ch-troubleshooting.html#sec-boot-problems">20.1. Boot Problems</a></span></dt><dt><span class="section"><a href="ch-troubleshooting.html#sec-maintenance-mode">20.2. Maintenance Mode</a></span></dt><dt><span class="section"><a href="ch-troubleshooting.html#sec-rollback">20.3. Rolling Back Configuration Changes</a></span></dt><dt><span class="section"><a href="ch-troubleshooting.html#sec-nix-store-corruption">20.4. Nix Store Corruption</a></span></dt><dt><span class="section"><a href="ch-troubleshooting.html#sec-nix-network-issues">20.5. Network Problems</a></span></dt></dl></div><p>This chapter describes solutions to common problems you might
encounter when you manage your NixOS system.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-boot-problems"></a>20.1. Boot Problems</h2></div></div></div><p>If NixOS fails to boot, there are a number of kernel command
line parameters that may help you to identify or fix the issue.  You
can add these parameters in the GRUB boot menu by pressing “e” to
modify the selected boot entry and editing the line starting with
<code class="literal">linux</code>.  The following are some useful kernel command
line parameters that are recognised by the NixOS boot scripts or by
systemd:

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">boot.shell_on_fail</code></span></dt><dd><p>Start a root shell if something goes wrong in
    stage 1 of the boot process (the initial ramdisk).  This is
    disabled by default because there is no authentication for the
    root shell.</p></dd><dt><span class="term"><code class="literal">boot.debug1</code></span></dt><dd><p>Start an interactive shell in stage 1 before
    anything useful has been done.  That is, no modules have been
    loaded and no file systems have been mounted, except for
    <code class="filename">/proc</code> and
    <code class="filename">/sys</code>.</p></dd><dt><span class="term"><code class="literal">boot.trace</code></span></dt><dd><p>Print every shell command executed by the stage 1
    and 2 boot scripts.</p></dd><dt><span class="term"><code class="literal">single</code></span></dt><dd><p>Boot into rescue mode (a.k.a. single user mode).
    This will cause systemd to start nothing but the unit
    <code class="literal">rescue.target</code>, which runs
    <span class="command"><strong>sulogin</strong></span> to prompt for the root password and
    start a root login shell.  Exiting the shell causes the system to
    continue with the normal boot process.</p></dd><dt><span class="term"><code class="literal">systemd.log_level=debug systemd.log_target=console</code></span></dt><dd><p>Make systemd very verbose and send log messages to
    the console instead of the journal.</p></dd></dl></div><p>

For more parameters recognised by systemd, see
<span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span>.</p><p>If no login prompts or X11 login screens appear (e.g. due to
hanging dependencies), you can press Alt+ArrowUp.  If you’re lucky,
this will start rescue mode (described above).  (Also note that since
most units have a 90-second timeout before systemd gives up on them,
the <span class="command"><strong>agetty</strong></span> login prompts should appear eventually
unless something is very wrong.)</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-maintenance-mode"></a>20.2. Maintenance Mode</h2></div></div></div><p>You can enter rescue mode by running:

</p><pre class="screen">
$ systemctl rescue</pre><p>

This will eventually give you a single-user root shell.  Systemd will
stop (almost) all system services.  To get out of maintenance mode,
just exit from the rescue shell.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-rollback"></a>20.3. Rolling Back Configuration Changes</h2></div></div></div><p>After running <span class="command"><strong>nixos-rebuild</strong></span> to switch to a
new configuration, you may find that the new configuration doesn’t
work very well.  In that case, there are several ways to return to a
previous configuration.</p><p>First, the GRUB boot manager allows you to boot into any
previous configuration that hasn’t been garbage-collected.  These
configurations can be found under the GRUB submenu “NixOS - All
configurations”.  This is especially useful if the new configuration
fails to boot.  After the system has booted, you can make the selected
configuration the default for subsequent boots:

</p><pre class="screen">
$ /run/current-system/bin/switch-to-configuration boot</pre><p>

</p><p>Second, you can switch to the previous configuration in a running
system:

</p><pre class="screen">
$ nixos-rebuild switch --rollback</pre><p>

This is equivalent to running:

</p><pre class="screen">
$ /nix/var/nix/profiles/system-<em class="replaceable"><code>N</code></em>-link/bin/switch-to-configuration switch</pre><p>

where <em class="replaceable"><code>N</code></em> is the number of the NixOS system
configuration.  To get a list of the available configurations, do:

</p><pre class="screen">
$ ls -l /nix/var/nix/profiles/system-*-link
<em class="replaceable"><code>...</code></em>
lrwxrwxrwx 1 root root 78 Aug 12 13:54 /nix/var/nix/profiles/system-268-link -&gt; /nix/store/202b...-nixos-13.07pre4932_5a676e4-4be1055
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-nix-store-corruption"></a>20.4. Nix Store Corruption</h2></div></div></div><p>After a system crash, it’s possible for files in the Nix store
to become corrupted.  (For instance, the Ext4 file system has the
tendency to replace un-synced files with zero bytes.)  NixOS tries
hard to prevent this from happening: it performs a
<span class="command"><strong>sync</strong></span> before switching to a new configuration, and
Nix’s database is fully transactional.  If corruption still occurs,
you may be able to fix it automatically.</p><p>If the corruption is in a path in the closure of the NixOS
system configuration, you can fix it by doing

</p><pre class="screen">
$ nixos-rebuild switch --repair
</pre><p>

This will cause Nix to check every path in the closure, and if its
cryptographic hash differs from the hash recorded in Nix’s database,
the path is rebuilt or redownloaded.</p><p>You can also scan the entire Nix store for corrupt paths:

</p><pre class="screen">
$ nix-store --verify --check-contents --repair
</pre><p>

Any corrupt paths will be redownloaded if they’re available in a
binary cache; otherwise, they cannot be repaired.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-nix-network-issues"></a>20.5. Network Problems</h2></div></div></div><p>Nix uses a so-called <span class="emphasis"><em>binary cache</em></span> to
optimise building a package from source into downloading it as a
pre-built binary.  That is, whenever a command like
<span class="command"><strong>nixos-rebuild</strong></span> needs a path in the Nix store, Nix
will try to download that path from the Internet rather than build it
from source.  The default binary cache is
<code class="uri">https://cache.nixos.org/</code>.  If this cache is unreachable,
Nix operations may take a long time due to HTTP connection timeouts.
You can disable the use of the binary cache by adding <code class="option">--option
use-binary-caches false</code>, e.g.

</p><pre class="screen">
$ nixos-rebuild switch --option use-binary-caches false
</pre><p>

If you have an alternative binary cache at your disposal, you can use
it instead:

</p><pre class="screen">
$ nixos-rebuild switch --option binary-caches http://my-cache.example.org/
</pre><p>

</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch-containers.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch-running.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="ch-development.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter 19. Container Management </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Part IV. Development</td></tr></table></div></body></html>