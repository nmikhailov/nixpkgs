<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>NixOS Manual</title><link rel="stylesheet" type="text/css" href="style.css" /><link rel="stylesheet" type="text/css" href="highlight.css" /><script src="highlight.js" type="text/javascript"></script><script src="init.js" type="text/javascript"></script><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="NixOS Manual" /><link rel="next" href="index.html#idm140737317410992" title="Preface" /></head><body><div class="book"><div class="titlepage"><div><div><h1 class="title"><a id="NixOSManual"></a>NixOS Manual</h1></div><div><h2 class="subtitle">Version 15.05pre56789.gfedcba
</h2></div></div><hr /></div><div class="toc"><dl class="toc"><dt><span class="preface"><a href="index.html#idm140737317410992">Preface</a></span></dt><dt><span class="part"><a href="index.html#ch-installation">I. Installation</a></span></dt><dd><dl><dt><span class="chapter"><a href="index.html#sec-obtaining">1. Obtaining NixOS</a></span></dt><dt><span class="chapter"><a href="index.html#sec-installation">2. Installing NixOS</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-uefi-installation">2.1. UEFI Installation</a></span></dt><dt><span class="section"><a href="index.html#sec-booting-from-usb">2.2. Booting from a USB Drive</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#sec-changing-config">3. Changing the Configuration</a></span></dt><dt><span class="chapter"><a href="index.html#sec-upgrading">4. Upgrading NixOS</a></span></dt></dl></dd><dt><span class="part"><a href="index.html#ch-configuration">II. Configuration</a></span></dt><dd><dl><dt><span class="chapter"><a href="index.html#sec-configuration-syntax">5. Configuration Syntax</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-configuration-file">5.1. NixOS Configuration File</a></span></dt><dt><span class="section"><a href="index.html#sec-module-abstractions">5.2. Abstractions</a></span></dt><dt><span class="section"><a href="index.html#sec-modularity">5.3. Modularity</a></span></dt><dt><span class="section"><a href="index.html#sec-nix-syntax-summary">5.4. Syntax Summary</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#sec-package-management">6. Package Management</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-declarative-package-mgmt">6.1. Declarative Package Management</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-customising-packages">6.1.1. Customising Packages</a></span></dt><dt><span class="section"><a href="index.html#sec-custom-packages">6.1.2. Adding Custom Packages</a></span></dt></dl></dd><dt><span class="section"><a href="index.html#sec-ad-hoc-packages">6.2. Ad-Hoc Package Management</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#sec-user-management">7. User Management</a></span></dt><dt><span class="chapter"><a href="index.html#ch-file-systems">8. File Systems</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-luks-file-systems">8.1. LUKS-Encrypted File Systems</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#sec-x11">9. X Window System</a></span></dt><dt><span class="chapter"><a href="index.html#sec-networking">10. Networking</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-networkmanager">10.1. NetworkManager</a></span></dt><dt><span class="section"><a href="index.html#sec-ssh">10.2. Secure Shell Access</a></span></dt><dt><span class="section"><a href="index.html#sec-ipv4">10.3. IPv4 Configuration</a></span></dt><dt><span class="section"><a href="index.html#sec-ipv6">10.4. IPv6 Configuration</a></span></dt><dt><span class="section"><a href="index.html#sec-firewall">10.5. Firewall</a></span></dt><dt><span class="section"><a href="index.html#sec-wireless">10.6. Wireless Networks</a></span></dt><dt><span class="section"><a href="index.html#ad-hoc-network-config">10.7. Ad-Hoc Configuration</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#sec-kernel-config">11. Linux Kernel</a></span></dt><dt><span class="chapter"><a href="index.html#module-postgresql">12. PostgreSQL</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#idm140737316585504">12.1. Configuring</a></span></dt><dt><span class="section"><a href="index.html#idm140737316579808">12.2. Upgrading</a></span></dt><dt><span class="section"><a href="index.html#idm140737316578592">12.3. Options</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="index.html#ch-running">III. Administration</a></span></dt><dd><dl><dt><span class="chapter"><a href="index.html#sec-systemctl">13. Service Management</a></span></dt><dt><span class="chapter"><a href="index.html#sec-rebooting">14. Rebooting and Shutting Down</a></span></dt><dt><span class="chapter"><a href="index.html#sec-user-sessions">15. User Sessions</a></span></dt><dt><span class="chapter"><a href="index.html#sec-cgroups">16. Control Groups</a></span></dt><dt><span class="chapter"><a href="index.html#sec-logging">17. Logging</a></span></dt><dt><span class="chapter"><a href="index.html#sec-nix-gc">18. Cleaning the Nix Store</a></span></dt><dt><span class="chapter"><a href="index.html#ch-containers">19. Container Management</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-imperative-containers">19.1. Imperative Container Management</a></span></dt><dt><span class="section"><a href="index.html#sec-declarative-containers">19.2. Declarative Container Specification</a></span></dt><dt><span class="section"><a href="index.html#sec-container-networking">19.3. Container Networking</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#ch-troubleshooting">20. Troubleshooting</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-boot-problems">20.1. Boot Problems</a></span></dt><dt><span class="section"><a href="index.html#sec-maintenance-mode">20.2. Maintenance Mode</a></span></dt><dt><span class="section"><a href="index.html#sec-rollback">20.3. Rolling Back Configuration Changes</a></span></dt><dt><span class="section"><a href="index.html#sec-nix-store-corruption">20.4. Nix Store Corruption</a></span></dt><dt><span class="section"><a href="index.html#sec-nix-network-issues">20.5. Network Problems</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="index.html#ch-development">IV. Development</a></span></dt><dd><dl><dt><span class="chapter"><a href="index.html#sec-getting-sources">21. Getting the Sources</a></span></dt><dt><span class="chapter"><a href="index.html#sec-writing-modules">22. Writing NixOS Modules</a></span></dt><dd><dl><dt><span class="section"><a href="index.html#sec-option-declarations">22.1. Option Declarations</a></span></dt><dt><span class="section"><a href="index.html#sec-option-definitions">22.2. Option Definitions</a></span></dt></dl></dd><dt><span class="chapter"><a href="index.html#sec-building-parts">23. Building Specific Parts of NixOS</a></span></dt><dt><span class="chapter"><a href="index.html#sec-building-cd">24. Building Your Own NixOS CD</a></span></dt><dt><span class="chapter"><a href="index.html#ch-testing-installer">25. Testing the Installer</a></span></dt></dl></dd><dt><span class="part"><a href="index.html#ch-release-notes">V. Release Notes</a></span></dt><dd><dl><dt><span class="chapter"><a href="index.html#sec-release-unstable">26. Unstable revision</a></span></dt><dt><span class="chapter"><a href="index.html#sec-release-14.12">27. Release 14.12 (“Caterpillar”, 2014/12/30)</a></span></dt><dt><span class="chapter"><a href="index.html#sec-release-14.04">28. Release 14.04 (“Baboon”, 2014/04/30)</a></span></dt><dt><span class="chapter"><a href="index.html#sec-release-13.10">29. Release 13.10 (“Aardvark”, 2013/10/31)</a></span></dt></dl></dd><dt><span class="appendix"><a href="ch-options.html">A. Configuration Options</a></span></dt></dl></div><div class="preface"><div class="titlepage"><div><div><h1 class="title"><a id="idm140737317410992"></a><a xmlns="" href="#idm140737317410992">Preface</a></h1></div></div></div><p>This manual describes how to install, use and extend NixOS,
    a Linux distribution based on the purely functional package
    management system Nix.</p><p>If you encounter problems, please report them on the
    <code class="literal"><a class="literal" href="http://lists.science.uu.nl/mailman/listinfo/nix-dev" target="_top">nix-dev@lists.science.uu.nl</a></code>
    mailing list or on the <a class="link" href="irc://irc.freenode.net/#nixos" target="_top">
    <code class="literal">#nixos</code> channel on Freenode</a>.  Bugs should
    be reported in <a class="link" href="https://github.com/NixOS/nixpkgs/issues" target="_top">NixOS’ GitHub
    issue tracker</a>.</p></div><div class="part"><div class="titlepage"><div><div><h1 xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="title"><a xmlns="http://www.w3.org/1999/xhtml" id="ch-installation"></a><a href="#ch-installation">Part I. Installation</a></h1></div></div></div><div class="partintro"><div></div><p>This section describes how to obtain, install, and configure
NixOS for first-time use.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-obtaining"></a><a xmlns="" href="#sec-obtaining">Chapter 1. Obtaining NixOS</a></h2></div></div></div><p>NixOS ISO images can be downloaded from the <a class="link" href="http://nixos.org/nixos/download.html" target="_top">NixOS
download page</a>.  There are a number of installation options.  If
you happen to have an optical drive and a spare CD, burning the
image to CD and booting from that is probably the easiest option.
Most people will need to prepare a USB stick to boot from.
Unetbootin is recommended and the process is described in brief below.
Note that systems which use UEFI require some additional manual steps.
If you run into difficulty a number of alternative methods are presented
in the <a class="link" href="https://nixos.org/wiki/Installing_NixOS_from_a_USB_stick" target="_top">NixOS
Wiki</a>.</p><p>As an alternative to installing NixOS yourself, you can get a
running NixOS system through several other means:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Using virtual appliances in Open Virtualization Format (OVF)
    that can be imported into VirtualBox.  These are available from
    the <a class="link" href="http://nixos.org/nixos/download.html" target="_top">NixOS
    download page</a>.</p></li><li class="listitem"><p>Using AMIs for Amazon’s EC2.  To find one for your region
    and instance type, please refer to the <a class="link" href="https://github.com/NixOS/nixops/blob/master/nix/ec2-amis.nix" target="_top">list
    of most recent AMIs</a>.</p></li><li class="listitem"><p>Using NixOps, the NixOS-based cloud deployment tool, which
    allows you to provision VirtualBox and EC2 NixOS instances from
    declarative specifications.  Check out the <a class="link" href="https://github.com/NixOS/nixops" target="_top">NixOps
    homepage</a> for details.</p></li></ul></div><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-installation"></a><a xmlns="" href="#sec-installation">Chapter 2. Installing NixOS</a></h2></div></div></div><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Boot from the CD.</p></li><li class="listitem"><p>The CD contains a basic NixOS installation.  (It
  also contains Memtest86+, useful if you want to test new hardware).
  When it’s finished booting, it should have detected most of your
  hardware.</p></li><li class="listitem"><p>The NixOS manual is available on virtual console 8
  (press Alt+F8 to access).</p></li><li class="listitem"><p>Login as <code class="literal">root</code> and the empty
  password.</p></li><li class="listitem"><p>If you downloaded the graphical ISO image, you can
  run <span class="command"><strong>start display-manager</strong></span> to start KDE.</p></li><li class="listitem"><p>The boot process should have brought up networking (check
  <span class="command"><strong>ip a</strong></span>).  Networking is necessary for the
  installer, since it will download lots of stuff (such as source
  tarballs or Nixpkgs channel binaries).  It’s best if you have a DHCP
  server on your network. Otherwise configure networking manually
  using <span class="command"><strong>ifconfig</strong></span>.</p><p>To manually configure the network on the graphical installer,
  first disable network-manager with
  <span class="command"><strong>systemctl stop network-manager</strong></span>.</p></li><li class="listitem"><p>The NixOS installer doesn’t do any partitioning or
  formatting yet, so you need to that yourself.  Use the following
  commands:

  </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>For partitioning:
    <span class="command"><strong>fdisk</strong></span>.</p></li><li class="listitem"><p>For initialising Ext4 partitions:
    <span class="command"><strong>mkfs.ext4</strong></span>.  It is recommended that you assign a
    unique symbolic label to the file system using the option
    <code class="option">-L <em class="replaceable"><code>label</code></em></code>, since this
    makes the file system configuration independent from device
    changes.  For example:

</p><pre class="screen ">
$ mkfs.ext4 -L nixos /dev/sda1</pre><p>

    </p></li><li class="listitem"><p>For creating swap partitions:
    <span class="command"><strong>mkswap</strong></span>.  Again it’s recommended to assign a
    label to the swap partition: <code class="option">-L
    <em class="replaceable"><code>label</code></em></code>.</p></li><li class="listitem"><p>For creating LVM volumes, the LVM commands, e.g.,

</p><pre class="screen ">
$ pvcreate /dev/sda1 /dev/sdb1
$ vgcreate MyVolGroup /dev/sda1 /dev/sdb1
$ lvcreate --size 2G --name bigdisk MyVolGroup
$ lvcreate --size 1G --name smalldisk MyVolGroup</pre><p>

    </p></li><li class="listitem"><p>For creating software RAID devices, use
    <span class="command"><strong>mdadm</strong></span>.</p></li></ul></div><p>

  </p></li><li class="listitem"><p>Mount the target file system on which NixOS should
  be installed on <code class="filename">/mnt</code>, e.g.

</p><pre class="screen ">
$ mount /dev/disk/by-label/nixos /mnt
</pre><p>

  </p></li><li class="listitem"><p>If your machine has a limited amount of memory, you
  may want to activate swap devices now (<span class="command"><strong>swapon
  <em class="replaceable"><code>device</code></em></strong></span>).  The installer (or
  rather, the build actions that it may spawn) may need quite a bit of
  RAM, depending on your configuration.</p></li><li class="listitem"><p>You now need to create a file
    <code class="filename">/mnt/etc/nixos/configuration.nix</code> that
    specifies the intended configuration of the system.  This is
    because NixOS has a <span class="emphasis"><em>declarative</em></span> configuration
    model: you create or edit a description of the desired
    configuration of your system, and then NixOS takes care of making
    it happen.  The syntax of the NixOS configuration file is
    described in <a class="xref" href="index.html#sec-configuration-syntax" title="Chapter 5. Configuration Syntax">Chapter 5, <em>Configuration Syntax</em></a>, while a
    list of available configuration options appears in <a class="xref" href="ch-options.html" title="Appendix A. Configuration Options">Appendix A, <em>Configuration Options</em></a>.  A minimal example is shown in <a class="xref" href="index.html#ex-config" title="Example 2.2. NixOS Configuration">Example 2.2, “NixOS Configuration”</a>.</p><p>The command <span class="command"><strong>nixos-generate-config</strong></span> can
    generate an initial configuration file for you:

</p><pre class="screen ">
$ nixos-generate-config --root /mnt</pre><p>

    You should then edit
    <code class="filename">/mnt/etc/nixos/configuration.nix</code> to suit your
    needs:

</p><pre class="screen ">
$ nano /mnt/etc/nixos/configuration.nix
</pre><p>

    The <span class="command"><strong>vim</strong></span> text editor is also available.</p><p>You <span class="emphasis"><em>must</em></span> set the option
    <code class="option">boot.loader.grub.device</code> to specify on which disk
    the GRUB boot loader is to be installed.  Without it, NixOS cannot
    boot.</p><p>Another critical option is <code class="option">fileSystems</code>,
    specifying the file systems that need to be mounted by NixOS.
    However, you typically don’t need to set it yourself, because
    <span class="command"><strong>nixos-generate-config</strong></span> sets it automatically in
    <code class="filename">/mnt/etc/nixos/hardware-configuration.nix</code>
    from your currently mounted file systems.  (The configuration file
    <code class="filename">hardware-configuration.nix</code> is included from
    <code class="filename">configuration.nix</code> and will be overwritten by
    future invocations of <span class="command"><strong>nixos-generate-config</strong></span>;
    thus, you generally should not modify it.)</p><div class="note"><h3 class="title">Note</h3><p>Depending on your hardware configuration or type of
    file system, you may need to set the option
    <code class="option">boot.initrd.kernelModules</code> to include the kernel
    modules that are necessary for mounting the root file system,
    otherwise the installed system will not be able to boot.  (If this
    happens, boot from the CD again, mount the target file system on
    <code class="filename">/mnt</code>, fix
    <code class="filename">/mnt/etc/nixos/configuration.nix</code> and rerun
    <code class="filename">nixos-install</code>.)  In most cases,
    <span class="command"><strong>nixos-generate-config</strong></span> will figure out the
    required modules.</p></div><p>Examples of real-world NixOS configuration files can be
    found at <a class="link" href="https://nixos.org/repos/nix/configurations/trunk/" target="_top">https://nixos.org/repos/nix/configurations/trunk/</a>.</p></li><li class="listitem"><p>Do the installation:

</p><pre class="screen ">
$ nixos-install</pre><p>

    Cross fingers.  If this fails due to a temporary problem (such as
    a network issue while downloading binaries from the NixOS binary
    cache), you can just re-run <span class="command"><strong>nixos-install</strong></span>.
    Otherwise, fix your <code class="filename">configuration.nix</code> and
    then re-run <span class="command"><strong>nixos-install</strong></span>.</p><p>As the last step, <span class="command"><strong>nixos-install</strong></span> will ask
    you to set the password for the <code class="literal">root</code> user, e.g.

</p><pre class="screen ">
setting root password...
Enter new UNIX password: ***
Retype new UNIX password: ***
</pre><p>

    </p></li><li class="listitem"><p>If everything went well:

</p><pre class="screen ">
$ reboot</pre><p>

  </p></li><li class="listitem"><p>You should now be able to boot into the installed NixOS. The GRUB boot menu shows a list
                of <span class="emphasis"><em>available configurations</em></span> (initially just one). Every time
                you change the NixOS configuration (see<a class="link" href="index.html#sec-changing-config" title="Chapter 3. Changing the Configuration">Changing
                    Configuration</a> ), a new item appears in the menu. This allows you to
                easily roll back to another configuration if something goes wrong.</p><p>You should log in and change the <code class="literal">root</code>
    password with <span class="command"><strong>passwd</strong></span>.</p><p>You’ll probably want to create some user accounts as well,
    which can be done with <span class="command"><strong>useradd</strong></span>:

</p><pre class="screen ">
$ useradd -c 'Eelco Dolstra' -m eelco
$ passwd eelco</pre><p>

    </p><p>You may also want to install some software.  For instance,

</p><pre class="screen ">
$ nix-env -qa \*</pre><p>

    shows what packages are available, and

</p><pre class="screen ">
$ nix-env -i w3m</pre><p>

    install the <code class="literal">w3m</code> browser.</p></li></ol></div><p>To summarise, <a class="xref" href="index.html#ex-install-sequence" title="Example 2.1. Commands for Installing NixOS on /dev/sda">Example 2.1, “Commands for Installing NixOS on <code class="filename">/dev/sda</code>”</a> shows a
typical sequence of commands for installing NixOS on an empty hard
drive (here <code class="filename">/dev/sda</code>).  <a class="xref" href="index.html#ex-config" title="Example 2.2. NixOS Configuration">Example 2.2, “NixOS Configuration”</a> shows a corresponding configuration Nix expression.</p><div class="example"><a id="ex-install-sequence"></a><p class="title"><strong>Example 2.1. Commands for Installing NixOS on <code class="filename">/dev/sda</code></strong></p><div class="example-contents"><pre class="screen ">
$ fdisk /dev/sda # <em class="lineannotation"><span class="lineannotation">(or whatever device you want to install on)</span></em>
$ mkfs.ext4 -L nixos /dev/sda1
$ mkswap -L swap /dev/sda2
$ swapon /dev/sda2
$ mount /dev/disk/by-label/nixos /mnt
$ nixos-generate-config --root /mnt
$ nano /mnt/etc/nixos/configuration.nix
$ nixos-install
$ reboot</pre></div></div><br class="example-break" /><div class="example"><a id="ex-config"></a><p class="title"><strong>Example 2.2. NixOS Configuration</strong></p><div class="example-contents"><pre class="screen ">
{ config, pkgs, ... }:

{
  imports =
    [ # Include the results of the hardware scan.
      ./hardware-configuration.nix
    ];

  boot.loader.grub.device = "/dev/sda";

  # Note: setting fileSystems is generally not
  # necessary, since nixos-generate-config figures them out
  # automatically in hardware-configuration.nix.
  #fileSystems."/".device = "/dev/disk/by-label/nixos";

  # Enable the OpenSSH server.
  services.sshd.enable = true;
}</pre></div></div><br class="example-break" /><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-uefi-installation"></a><a xmlns="" href="#sec-uefi-installation">2.1. UEFI Installation</a></h2></div></div></div><p>NixOS can also be installed on UEFI systems.  The procedure
is by and large the same as a BIOS installation, with the following
changes:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>You should boot the live CD in UEFI mode (consult your
    specific hardware's documentation for instructions). You may find
    the <a class="link" href="http://www.rodsbooks.com/refind" target="_top">rEFInd
    boot manager</a> useful.</p></li><li class="listitem"><p>Instead of <span class="command"><strong>fdisk</strong></span>, you should use
    <span class="command"><strong>gdisk</strong></span> to partition your disks. You will need to
    have a separate partition for <code class="filename">/boot</code> with
    partition code EF00, and it should be formatted as a
    <code class="literal">vfat</code> filesystem.</p></li><li class="listitem"><p>You must set <code class="option">boot.loader.gummiboot.enable</code> to
    <code class="literal">true</code>. <span class="command"><strong>nixos-generate-config</strong></span>
    should do this automatically for new configurations when booted in
    UEFI mode.</p></li><li class="listitem"><p>After having mounted your installation partition to
    <code class="code">/mnt</code>, you must mount the <code class="code">boot</code> partition
    to <code class="code">/mnt/boot</code>.</p></li><li class="listitem"><p>You may want to look at the options starting with
    <code class="option">boot.loader.efi</code> and <code class="option">boot.loader.gummiboot</code>
    as well.</p></li><li class="listitem"><p>To see console messages during early boot, add <code class="literal">"fbcon"</code>
    to your <code class="option">boot.initrd.kernelModules</code>.</p></li></ul></div><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-booting-from-usb"></a><a xmlns="" href="#sec-booting-from-usb">2.2. Booting from a USB Drive</a></h2></div></div></div><p>For systems without CD drive, the NixOS livecd can be booted from
a usb stick. For non-UEFI installations,
<a class="link" href="http://unetbootin.sourceforge.net/" target="_top">unetbootin</a>
will work. For UEFI installations, you should mount the ISO, copy its contents
verbatim to your drive, then either:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Change the label of the disk partition to the label of the ISO
    (visible with the blkid command), or</p></li><li class="listitem"><p>Edit <code class="filename">loader/entries/nixos-livecd.conf</code> on the drive
    and change the <code class="literal">root=</code> field in the <code class="literal">options</code>
    line to point to your drive (see the documentation on <code class="literal">root=</code>
    in <a class="link" href="https://www.kernel.org/doc/Documentation/kernel-parameters.txt" target="_top">
    the kernel documentation</a> for more details).</p></li></ul></div><p>
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-changing-config"></a><a xmlns="" href="#sec-changing-config">Chapter 3. Changing the Configuration</a></h2></div></div></div><p>The file <code class="filename">/etc/nixos/configuration.nix</code>
contains the current configuration of your machine.  Whenever you’ve
changed something to that file, you should do

</p><pre class="screen ">
$ nixos-rebuild switch</pre><p>

to build the new configuration, make it the default configuration for
booting, and try to realise the configuration in the running system
(e.g., by restarting system services).</p><div class="warning"><h3 class="title">Warning</h3><p>These commands must be executed as root, so you should
either run them from a root shell or by prefixing them with
<code class="literal">sudo -i</code>.</p></div><p>You can also do

</p><pre class="screen ">
$ nixos-rebuild test</pre><p>

to build the configuration and switch the running system to it, but
without making it the boot default.  So if (say) the configuration
locks up your machine, you can just reboot to get back to a working
configuration.</p><p>There is also

</p><pre class="screen ">
$ nixos-rebuild boot</pre><p>

to build the configuration and make it the boot default, but not
switch to it now (so it will only take effect after the next
reboot).</p><p>You can make your configuration show up in a different submenu
of the GRUB 2 boot screen by giving it a different <span class="emphasis"><em>profile
name</em></span>, e.g.

</p><pre class="screen ">
$ nixos-rebuild switch -p test </pre><p>

which causes the new configuration (and previous ones created using
<code class="literal">-p test</code>) to show up in the GRUB submenu “NixOS -
Profile 'test'”.  This can be useful to separate test configurations
from “stable” configurations.</p><p>Finally, you can do

</p><pre class="screen ">
$ nixos-rebuild build</pre><p>

to build the configuration but nothing more.  This is useful to see
whether everything compiles cleanly.</p><p>If you have a machine that supports hardware virtualisation, you
can also test the new configuration in a sandbox by building and
running a QEMU <span class="emphasis"><em>virtual machine</em></span> that contains the
desired configuration.  Just do

</p><pre class="screen ">
$ nixos-rebuild build-vm
$ ./result/bin/run-*-vm
</pre><p>

The VM does not have any data from your host system, so your existing
user accounts and home directories will not be available.  You can
forward ports on the host to the guest.  For instance, the following
will forward host port 2222 to guest port 22 (SSH):

</p><pre class="screen ">
$ QEMU_NET_OPTS="hostfwd=tcp::2222-:22" ./result/bin/run-*-vm
</pre><p>

allowing you to log in via SSH (assuming you have set the appropriate
passwords or SSH authorized keys):

</p><pre class="screen ">
$ ssh -p 2222 localhost
</pre><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-upgrading"></a><a xmlns="" href="#sec-upgrading">Chapter 4. Upgrading NixOS</a></h2></div></div></div><p>The best way to keep your NixOS installation up to date is to
use one of the NixOS <span class="emphasis"><em>channels</em></span>.  A channel is a
Nix mechanism for distributing Nix expressions and associated
binaries.  The NixOS channels are updated automatically from NixOS’s
Git repository after certain tests have passed and all packages have
been built.  These channels are:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Stable channels</em></span>, such as <code class="literal"><a class="literal" href="https://nixos.org/channels/nixos-14.12" target="_top">nixos-14.12</a></code>.
    These only get conservative bug fixes and package upgrades.  For
    instance, a channel update may cause the Linux kernel on your
    system to be upgraded from 3.4.66 to 3.4.67 (a minor bug fix), but
    not from 3.4.<em class="replaceable"><code>x</code></em> to
    3.11.<em class="replaceable"><code>x</code></em> (a major change that has the
    potential to break things).  Stable channels are generally
    maintained until the next stable branch is created.</p><p></p></li><li class="listitem"><p>The <span class="emphasis"><em>unstable channel</em></span>, <code class="literal"><a class="literal" href="https://nixos.org/channels/nixos-unstable" target="_top">nixos-unstable</a></code>.
    This corresponds to NixOS’s main development branch, and may thus
    see radical changes between channel updates.  It’s not recommended
    for production systems.</p></li><li class="listitem"><p><span class="emphasis"><em>Small channels</em></span>, such as <code class="literal"><a class="literal" href="https://nixos.org/channels/nixos-14.12-small" target="_top">nixos-14.12-small</a></code>
    or <code class="literal"><a class="literal" href="https://nixos.org/channels/nixos-unstable-small" target="_top">nixos-unstable-small</a></code>. These
    are identical to the stable and unstable channels described above,
    except that they contain fewer binary packages. This means they
    get updated faster than the regular channels (for instance, when a
    critical security patch is committed to NixOS’s source tree), but
    may require more packages to be built from source than
    usual. They’re mostly intended for server environments and as such
    contain few GUI applications.</p></li></ul></div><p>

To see what channels are available, go to <a class="link" href="https://nixos.org/channels" target="_top">https://nixos.org/channels</a>.  (Note that the URIs of the
various channels redirect to a directory that contains the channel’s
latest version and includes ISO images and VirtualBox
appliances.)</p><p>When you first install NixOS, you’re automatically subscribed to
the NixOS channel that corresponds to your installation source.   For
instance, if you installed from a 14.12 ISO, you will be subscribed to
the <code class="literal">nixos-14.12</code> channel.  To see which NixOS
channel you’re subscribed to, run the following as root:

</p><pre class="screen ">
$ nix-channel --list | grep nixos
nixos https://nixos.org/channels/nixos-unstable
</pre><p>

To switch to a different NixOS channel, do

</p><pre class="screen ">
$ nix-channel --add https://nixos.org/channels/<em class="replaceable"><code>channel-name</code></em> nixos
</pre><p>

(Be sure to include the <code class="literal">nixos</code> parameter at the
end.)  For instance, to use the NixOS 14.12 stable channel:

</p><pre class="screen ">
$ nix-channel --add https://nixos.org/channels/nixos-14.12 nixos
</pre><p>

If you have a server, you may want to use the “small” channel instead:

</p><pre class="screen ">
$ nix-channel --add https://nixos.org/channels/nixos-14.12-small nixos
</pre><p>

And if you want to live on the bleeding edge:

</p><pre class="screen ">
$ nix-channel --add https://nixos.org/channels/nixos-unstable nixos
</pre><p>

</p><p>You can then upgrade NixOS to the latest version in your chosen
channel by running

</p><pre class="screen ">
$ nixos-rebuild switch --upgrade
</pre><p>

which is equivalent to the more verbose <code class="literal">nix-channel --update
nixos; nixos-rebuild switch</code>.</p><div class="warning"><h3 class="title">Warning</h3><p>It is generally safe to switch back and forth between
channels.  The only exception is that a newer NixOS may also have a
newer Nix version, which may involve an upgrade of Nix’s database
schema.  This cannot be undone easily, so in that case you will not be
able to go back to your original channel.</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="title"><a xmlns="http://www.w3.org/1999/xhtml" id="ch-configuration"></a><a href="#ch-configuration">Part II. Configuration</a></h1></div></div></div><div class="partintro"><div></div><p>This chapter describes how to configure various aspects of a
NixOS machine through the configuration file
<code class="filename">/etc/nixos/configuration.nix</code>.  As described in
<a class="xref" href="index.html#sec-changing-config" title="Chapter 3. Changing the Configuration">Chapter 3, <em>Changing the Configuration</em></a>, changes to this file only take
effect after you run <span class="command"><strong>nixos-rebuild</strong></span>.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-configuration-syntax"></a><a xmlns="" href="#sec-configuration-syntax">Chapter 5. Configuration Syntax</a></h2></div></div></div><p>The NixOS configuration file
<code class="filename">/etc/nixos/configuration.nix</code> is actually a
<span class="emphasis"><em>Nix expression</em></span>, which is the Nix package
manager’s purely functional language for describing how to build
packages and configurations.  This means you have all the expressive
power of that language at your disposal, including the ability to
abstract over common patterns, which is very useful when managing
complex systems.  The syntax and semantics of the Nix language are
fully described in the <a class="link" href="http://nixos.org/nix/manual/#chap-writing-nix-expressions" target="_top">Nix
manual</a>, but here we give a short overview of the most important
constructs useful in NixOS configuration files.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-configuration-file"></a><a xmlns="" href="#sec-configuration-file">5.1. NixOS Configuration File</a></h2></div></div></div><p>The NixOS configuration file generally looks like this:

</p><pre class="programlisting nix">
{ config, pkgs, ... }:

{ <em class="replaceable"><code>option definitions</code></em>
}
</pre><p>

The first line (<code class="literal">{ config, pkgs, ... }:</code>) denotes
that this is actually a function that takes at least the two arguments
 <code class="varname">config</code> and <code class="varname">pkgs</code>.  (These are
explained later.)  The function returns a <span class="emphasis"><em>set</em></span> of
option definitions (<code class="literal">{ <em class="replaceable"><code>...</code></em> }</code>).  These definitions have the
form <code class="literal"><em class="replaceable"><code>name</code></em> =
<em class="replaceable"><code>value</code></em></code>, where
<em class="replaceable"><code>name</code></em> is the name of an option and
<em class="replaceable"><code>value</code></em> is its value.  For example,

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ services.httpd.enable = true;
  services.httpd.adminAddr = "alice@example.org";
  services.httpd.documentRoot = "/webroot";
}
</pre><p>

defines a configuration with three option definitions that together
enable the Apache HTTP Server with <code class="filename">/webroot</code> as
the document root.</p><p>Sets can be nested, and in fact dots in option names are
shorthand for defining a set containing another set.  For instance,
<code class="option">services.httpd.enable</code> defines a set named
<code class="varname">services</code> that contains a set named
<code class="varname">httpd</code>, which in turn contains an option definition
named <code class="varname">enable</code> with value <code class="literal">true</code>.
This means that the example above can also be written as:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ services = {
    httpd = {
      enable = true;
      adminAddr = "alice@example.org";
      documentRoot = "/webroot";
    };
  };
}
</pre><p>

which may be more convenient if you have lots of option definitions
that share the same prefix (such as
<code class="literal">services.httpd</code>).</p><p>NixOS checks your option definitions for correctness.  For
instance, if you try to define an option that doesn’t exist (that is,
doesn’t have a corresponding <span class="emphasis"><em>option declaration</em></span>),
<span class="command"><strong>nixos-rebuild</strong></span> will give an error like:
</p><pre class="screen nohighlight hljs">
The option `services.httpd.enable' defined in `/etc/nixos/configuration.nix' does not exist.
</pre><p>
Likewise, values in option definitions must have a correct type.  For
instance, <code class="option">services.httpd.enable</code> must be a Boolean
(<code class="literal">true</code> or <code class="literal">false</code>).  Trying to give
it a value of another type, such as a string, will cause an error:
</p><pre class="screen nohighlight hljs">
The option value `services.httpd.enable' in `/etc/nixos/configuration.nix' is not a boolean.
</pre><p>

</p><p>Options have various types of values.  The most important are:

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Strings</span></dt><dd><p>Strings are enclosed in double quotes, e.g.

</p><pre class="programlisting ">
networking.hostName = "dexter";
</pre><p>

      Special characters can be escaped by prefixing them with a
      backslash (e.g. <code class="literal">\"</code>).</p><p>Multi-line strings can be enclosed in <span class="emphasis"><em>double
      single quotes</em></span>, e.g.

</p><pre class="programlisting nix">
networking.extraHosts =
  ''
    127.0.0.2 other-localhost
    10.0.0.1 server
  '';
</pre><p>

      The main difference is that preceding whitespace is
      automatically stripped from each line, and that characters like
      <code class="literal">"</code> and <code class="literal">\</code> are not special
      (making it more convenient for including things like shell
      code).</p></dd><dt><span class="term">Booleans</span></dt><dd><p>These can be <code class="literal">true</code> or
      <code class="literal">false</code>, e.g.

</p><pre class="programlisting ">
networking.firewall.enable = true;
networking.firewall.allowPing = false;
</pre><p>
      </p></dd><dt><span class="term">Integers</span></dt><dd><p>For example,

</p><pre class="programlisting nix">
boot.kernel.sysctl."net.ipv4.tcp_keepalive_time" = 60;
</pre><p>

      (Note that here the attribute name
      <code class="literal">net.ipv4.tcp_keepalive_time</code> is enclosed in
      quotes to prevent it from being interpreted as a set named
      <code class="literal">net</code> containing a set named
      <code class="literal">ipv4</code>, and so on.  This is because it’s not a
      NixOS option but the literal name of a Linux kernel
      setting.)</p></dd><dt><span class="term">Sets</span></dt><dd><p>Sets were introduced above.  They are name/value pairs
      enclosed in braces, as in the option definition

</p><pre class="programlisting ">
fileSystems."/boot" =
  { device = "/dev/sda1";
    fsType = "ext4";
    options = "rw,data=ordered,relatime";
  };
</pre><p>
      </p></dd><dt><span class="term">Lists</span></dt><dd><p>The important thing to note about lists is that list
      elements are separated by whitespace, like this:

</p><pre class="programlisting ">
boot.kernelModules = [ "fuse" "kvm-intel" "coretemp" ];
</pre><p>

      List elements can be any other type, e.g. sets:

</p><pre class="programlisting ">
swapDevices = [ { device = "/dev/disk/by-label/swap"; } ];
</pre><p>
      </p></dd><dt><span class="term">Packages</span></dt><dd><p>Usually, the packages you need are already part of the Nix
      Packages collection, which is a set that can be accessed through
      the function argument <code class="varname">pkgs</code>.  Typical uses:

</p><pre class="programlisting ">
environment.systemPackages =
  [ pkgs.thunderbird
    pkgs.emacs
  ];

postgresql.package = pkgs.postgresql90;
</pre><p>

      The latter option definition changes the default PostgreSQL
      package used by NixOS’s PostgreSQL service to 9.0.  For more
      information on packages, including how to add new ones, see
      <a class="xref" href="index.html#sec-custom-packages" title="6.1.2. Adding Custom Packages">Section 6.1.2, “Adding Custom Packages”</a>.</p></dd></dl></div><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-module-abstractions"></a><a xmlns="" href="#sec-module-abstractions">5.2. Abstractions</a></h2></div></div></div><p>If you find yourself repeating yourself over and over, it’s time
to abstract.  Take, for instance, this Apache HTTP Server configuration:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    [ { hostName = "example.org";
        documentRoot = "/webroot";
        adminAddr = "alice@example.org";
        enableUserDir = true;
      }
      { hostName = "example.org";
        documentRoot = "/webroot";
        adminAddr = "alice@example.org";
        enableUserDir = true;
        enableSSL = true;
        sslServerCert = "/root/ssl-example-org.crt";
        sslServerKey = "/root/ssl-example-org.key";
      }
    ];
}
</pre><p>

It defines two virtual hosts with nearly identical configuration; the
only difference is that the second one has SSL enabled.  To prevent
this duplication, we can use a <code class="literal">let</code>:

</p><pre class="programlisting ">
let
  exampleOrgCommon =
    { hostName = "example.org";
      documentRoot = "/webroot";
      adminAddr = "alice@example.org";
      enableUserDir = true;
    };
in
{
  services.httpd.virtualHosts =
    [ exampleOrgCommon
      (exampleOrgCommon // {
        enableSSL = true;
        sslServerCert = "/root/ssl-example-org.crt";
        sslServerKey = "/root/ssl-example-org.key";
      })
    ];
}
</pre><p>

The <code class="literal">let exampleOrgCommon =
<em class="replaceable"><code>...</code></em></code> defines a variable named
<code class="literal">exampleOrgCommon</code>.  The <code class="literal">//</code>
operator merges two attribute sets, so the configuration of the second
virtual host is the set <code class="literal">exampleOrgCommon</code> extended
with the SSL options.</p><p>You can write a <code class="literal">let</code> wherever an expression is
allowed.  Thus, you also could have written:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let exampleOrgCommon = <em class="replaceable"><code>...</code></em>; in
    [ exampleOrgCommon
      (exampleOrgCommon // { <em class="replaceable"><code>...</code></em> })
    ];
}
</pre><p>

but not <code class="literal">{ let exampleOrgCommon =
<em class="replaceable"><code>...</code></em>; in <em class="replaceable"><code>...</code></em>;
}</code> since attributes (as opposed to attribute values) are not
expressions.</p><p><span class="emphasis"><em>Functions</em></span> provide another method of
abstraction.  For instance, suppose that we want to generate lots of
different virtual hosts, all with identical configuration except for
the host name.  This can be done as follows:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let
      makeVirtualHost = name:
        { hostName = name;
          documentRoot = "/webroot";
          adminAddr = "alice@example.org";
        };
    in
      [ (makeVirtualHost "example.org")
        (makeVirtualHost "example.com")
        (makeVirtualHost "example.gov")
        (makeVirtualHost "example.nl")
      ];
}
</pre><p>

Here, <code class="varname">makeVirtualHost</code> is a function that takes a
single argument <code class="literal">name</code> and returns the configuration
for a virtual host.  That function is then called for several names to
produce the list of virtual host configurations.</p><p>We can further improve on this by using the function
<code class="varname">map</code>, which applies another function to every
element in a list:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let
      makeVirtualHost = <em class="replaceable"><code>...</code></em>;
    in map makeVirtualHost
      [ "example.org" "example.com" "example.gov" "example.nl" ];
}
</pre><p>

(The function <code class="literal">map</code> is called a
<span class="emphasis"><em>higher-order function</em></span> because it takes another
function as an argument.)</p><p>What if you need more than one argument, for instance, if we
want to use a different <code class="literal">documentRoot</code> for each
virtual host?  Then we can make <code class="varname">makeVirtualHost</code> a
function that takes a <span class="emphasis"><em>set</em></span> as its argument, like this:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let
      makeVirtualHost = { name, root }:
        { hostName = name;
          documentRoot = root;
          adminAddr = "alice@example.org";
        };
    in map makeVirtualHost
      [ { name = "example.org"; root = "/sites/example.org"; }
        { name = "example.com"; root = "/sites/example.com"; }
        { name = "example.gov"; root = "/sites/example.gov"; }
        { name = "example.nl"; root = "/sites/example.nl"; }
      ];
}
</pre><p>

But in this case (where every root is a subdirectory of
<code class="filename">/sites</code> named after the virtual host), it would
have been shorter to define <code class="varname">makeVirtualHost</code> as
</p><pre class="programlisting ">
makeVirtualHost = name:
  { hostName = name;
    documentRoot = "/sites/${name}";
    adminAddr = "alice@example.org";
  };
</pre><p>

Here, the construct
<code class="literal">${<em class="replaceable"><code>...</code></em>}</code> allows the result
of an expression to be spliced into a string.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-modularity"></a><a xmlns="" href="#sec-modularity">5.3. Modularity</a></h2></div></div></div><p>The NixOS configuration mechanism is modular.  If your
<code class="filename">configuration.nix</code> becomes too big, you can split
it into multiple files.  Likewise, if you have multiple NixOS
configurations (e.g. for different computers) with some commonality,
you can move the common configuration into a shared file.</p><p>Modules have exactly the same syntax as
<code class="filename">configuration.nix</code>.  In fact,
<code class="filename">configuration.nix</code> is itself a module.  You can
use other modules by including them from
<code class="filename">configuration.nix</code>, e.g.:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ imports = [ ./vpn.nix ./kde.nix ];
  services.httpd.enable = true;
  environment.systemPackages = [ pkgs.emacs ];
  <em class="replaceable"><code>...</code></em>
}
</pre><p>

Here, we include two modules from the same directory,
<code class="filename">vpn.nix</code> and <code class="filename">kde.nix</code>.  The
latter might look like this:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ services.xserver.enable = true;
  services.xserver.displayManager.kdm.enable = true;
  services.xserver.desktopManager.kde4.enable = true;
  environment.systemPackages = [ pkgs.kde4.kscreensaver ];
}
</pre><p>

Note that both <code class="filename">configuration.nix</code> and
<code class="filename">kde.nix</code> define the option
<code class="option">environment.systemPackages</code>.  When multiple modules
define an option, NixOS will try to <span class="emphasis"><em>merge</em></span> the
definitions.  In the case of
<code class="option">environment.systemPackages</code>, that’s easy: the lists of
packages can simply be concatenated.  The value in
<code class="filename">configuration.nix</code> is merged last, so for
list-type options, it will appear at the end of the merged list. If
you want it to appear first, you can use <code class="varname">mkBefore</code>:

</p><pre class="programlisting ">
boot.kernelModules = mkBefore [ "kvm-intel" ];
</pre><p>

This causes the <code class="literal">kvm-intel</code> kernel module to be
loaded before any other kernel modules.</p><p>For other types of options, a merge may not be possible. For
instance, if two modules define
<code class="option">services.httpd.adminAddr</code>,
<span class="command"><strong>nixos-rebuild</strong></span> will give an error:

</p><pre class="screen nohighlight hljs">
The unique option `services.httpd.adminAddr' is defined multiple times, in `/etc/nixos/httpd.nix' and `/etc/nixos/configuration.nix'.
</pre><p>

When that happens, it’s possible to force one definition take
precedence over the others:

</p><pre class="programlisting ">
services.httpd.adminAddr = pkgs.lib.mkForce "bob@example.org";
</pre><p>

</p><p>When using multiple modules, you may need to access
configuration values defined in other modules.  This is what the
<code class="varname">config</code> function argument is for: it contains the
complete, merged system configuration.  That is,
<code class="varname">config</code> is the result of combining the
configurations returned by every module<a href="#ftn.idm140737316843760" class="footnote" id="idm140737316843760"><sup class="footnote">[1]</sup></a>.  For example, here is a module that adds
some packages to <code class="option">environment.systemPackages</code> only if
<code class="option">services.xserver.enable</code> is set to
<code class="literal">true</code> somewhere else:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ environment.systemPackages =
    if config.services.xserver.enable then
      [ pkgs.firefox
        pkgs.thunderbird
      ]
    else
      [ ];
}
</pre><p>

</p><p>With multiple modules, it may not be obvious what the final
value of a configuration option is.  The command
<code class="option">nixos-option</code> allows you to find out:

</p><pre class="screen ">
$ nixos-option services.xserver.enable
true

$ nixos-option boot.kernelModules
[ "tun" "ipv6" "loop" <em class="replaceable"><code>...</code></em> ]
</pre><p>

Interactive exploration of the configuration is possible using
<span class="command"><strong><a class="command" href="https://github.com/edolstra/nix-repl" target="_top">nix-repl</a></strong></span>,
a read-eval-print loop for Nix expressions.  It’s not installed by
default; run <code class="literal">nix-env -i nix-repl</code> to get it.  A
typical use:

</p><pre class="screen ">
$ nix-repl '&lt;nixos&gt;'

nix-repl&gt; config.networking.hostName
"mandark"

nix-repl&gt; map (x: x.hostName) config.services.httpd.virtualHosts
[ "example.org" "example.gov" ]
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-nix-syntax-summary"></a><a xmlns="" href="#sec-nix-syntax-summary">5.4. Syntax Summary</a></h2></div></div></div><p>Below is a summary of the most important syntactic constructs in
the Nix expression language.  It’s not complete.  In particular, there
are many other built-in functions.  See the <a class="link" href="http://nixos.org/nix/manual/#chap-writing-nix-expressions" target="_top">Nix
manual</a> for the rest.</p><div class="informaltable"><table border="0"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td colspan="2"><span class="emphasis"><em>Basic values</em></span></td></tr><tr><td><code class="literal">"Hello world"</code></td><td>A string</td></tr><tr><td><code class="literal">"${pkgs.bash}/bin/sh"</code></td><td>A string containing an expression (expands to <code class="literal">"/nix/store/<em class="replaceable"><code>hash</code></em>-bash-<em class="replaceable"><code>version</code></em>/bin/sh"</code>)</td></tr><tr><td><code class="literal">true</code>, <code class="literal">false</code></td><td>Booleans</td></tr><tr><td><code class="literal">123</code></td><td>An integer</td></tr><tr><td><code class="literal">./foo.png</code></td><td>A path (relative to the containing Nix expression)</td></tr><tr><td colspan="2"><span class="emphasis"><em>Compound values</em></span></td></tr><tr><td><code class="literal">{ x = 1; y = 2; }</code></td><td>An set with attributes names <code class="literal">x</code> and <code class="literal">y</code></td></tr><tr><td><code class="literal">{ foo.bar = 1; }</code></td><td>A nested set, equivalent to <code class="literal">{ foo = { bar = 1; }; }</code></td></tr><tr><td><code class="literal">rec { x = "foo"; y = x + "bar"; }</code></td><td>A recursive set, equivalent to <code class="literal">{ x = "foo"; y = "foobar"; }</code></td></tr><tr><td><code class="literal">[ "foo" "bar" ]</code></td><td>A list with two elements</td></tr><tr><td colspan="2"><span class="emphasis"><em>Operators</em></span></td></tr><tr><td><code class="literal">"foo" + "bar"</code></td><td>String concatenation</td></tr><tr><td><code class="literal">1 + 2</code></td><td>Integer addition</td></tr><tr><td><code class="literal">"foo" == "f" + "oo"</code></td><td>Equality test (evaluates to <code class="literal">true</code>)</td></tr><tr><td><code class="literal">"foo" != "bar"</code></td><td>Inequality test (evaluates to <code class="literal">true</code>)</td></tr><tr><td><code class="literal">!true</code></td><td>Boolean negation</td></tr><tr><td><code class="literal">{ x = 1; y = 2; }.x</code></td><td>Attribute selection (evaluates to <code class="literal">1</code>)</td></tr><tr><td><code class="literal">{ x = 1; y = 2; }.z or 3</code></td><td>Attribute selection with default (evaluates to <code class="literal">3</code>)</td></tr><tr><td><code class="literal">{ x = 1; y = 2; } // { z = 3; }</code></td><td>Merge two sets (attributes in the right-hand set taking precedence)</td></tr><tr><td colspan="2"><span class="emphasis"><em>Control structures</em></span></td></tr><tr><td><code class="literal">if 1 + 1 == 2 then "yes!" else "no!"</code></td><td>Conditional expression</td></tr><tr><td><code class="literal">assert 1 + 1 == 2; "yes!"</code></td><td>Assertion check (evaluates to <code class="literal">"yes!"</code>)</td></tr><tr><td><code class="literal">let x = "foo"; y = "bar"; in x + y</code></td><td>Variable definition</td></tr><tr><td><code class="literal">with pkgs.lib; head [ 1 2 3 ]</code></td><td>Add all attributes from the given set to the scope
        (evaluates to <code class="literal">1</code>)</td></tr><tr><td colspan="2"><span class="emphasis"><em>Functions (lambdas)</em></span></td></tr><tr><td><code class="literal">x: x + 1</code></td><td>A function that expects an integer and returns it increased by 1</td></tr><tr><td><code class="literal">(x: x + 1) 100</code></td><td>A function call (evaluates to 101)</td></tr><tr><td><code class="literal">let inc = x: x + 1; in inc (inc (inc 100))</code></td><td>A function bound to a variable and subsequently called by name (evaluates to 103)</td></tr><tr><td><code class="literal">{ x, y }: x + y</code></td><td>A function that expects a set with required attributes
        <code class="literal">x</code> and <code class="literal">y</code> and concatenates
        them</td></tr><tr><td><code class="literal">{ x, y ? "bar" }: x + y</code></td><td>A function that expects a set with required attribute
        <code class="literal">x</code> and optional <code class="literal">y</code>, using
        <code class="literal">"bar"</code> as default value for
        <code class="literal">y</code></td></tr><tr><td><code class="literal">{ x, y, ... }: x + y</code></td><td>A function that expects a set with required attributes
        <code class="literal">x</code> and <code class="literal">y</code> and ignores any
        other attributes</td></tr><tr><td><code class="literal">{ x, y } @ args: x + y</code></td><td>A function that expects a set with required attributes
        <code class="literal">x</code> and <code class="literal">y</code>, and binds the
        whole set to <code class="literal">args</code></td></tr><tr><td colspan="2"><span class="emphasis"><em>Built-in functions</em></span></td></tr><tr><td><code class="literal">import ./foo.nix</code></td><td>Load and return Nix expression in given file</td></tr><tr><td><code class="literal">map (x: x + x) [ 1 2 3 ]</code></td><td>Apply a function to every element of a list (evaluates to <code class="literal">[ 2 4 6 ]</code>)</td></tr></tbody></table></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm140737316843760" class="footnote"><p><a href="#idm140737316843760" class="para"><sup class="para">[1] </sup></a>If you’re
wondering how it’s possible that the (indirect)
<span class="emphasis"><em>result</em></span> of a function is passed as an
<span class="emphasis"><em>input</em></span> to that same function: that’s because Nix
is a “lazy” language — it only computes values when they are needed.
This works as long as no individual configuration value depends on
itself.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-package-management"></a><a xmlns="" href="#sec-package-management">Chapter 6. Package Management</a></h2></div></div></div><p>This section describes how to add additional packages to your
system.  NixOS has two distinct styles of package management:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><span class="emphasis"><em>Declarative</em></span>, where you declare
  what packages you want in your
  <code class="filename">configuration.nix</code>.  Every time you run
  <span class="command"><strong>nixos-rebuild</strong></span>, NixOS will ensure that you get a
  consistent set of binaries corresponding to your
  specification.</p></li><li class="listitem"><p><span class="emphasis"><em>Ad hoc</em></span>, where you install,
  upgrade and uninstall packages via the <span class="command"><strong>nix-env</strong></span>
  command.  This style allows mixing packages from different Nixpkgs
  versions.  It’s the only choice for non-root
  users.</p></li></ul></div><p>

</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-declarative-package-mgmt"></a><a xmlns="" href="#sec-declarative-package-mgmt">6.1. Declarative Package Management</a></h2></div></div></div><p>With declarative package management, you specify which packages
you want on your system by setting the option
<code class="option">environment.systemPackages</code>.  For instance, adding the
following line to <code class="filename">configuration.nix</code> enables the
Mozilla Thunderbird email application:

</p><pre class="programlisting ">
environment.systemPackages = [ pkgs.thunderbird ];
</pre><p>

The effect of this specification is that the Thunderbird package from
Nixpkgs will be built or downloaded as part of the system when you run
<span class="command"><strong>nixos-rebuild switch</strong></span>.</p><p>You can get a list of the available packages as follows:
</p><pre class="screen ">
$ nix-env -qaP '*' --description
nixos.pkgs.firefox   firefox-23.0   Mozilla Firefox - the browser, reloaded
<em class="replaceable"><code>...</code></em>
</pre><p>

The first column in the output is the <span class="emphasis"><em>attribute
name</em></span>, such as
<code class="literal">nixos.pkgs.thunderbird</code>. (The
<code class="literal">nixos</code> prefix allows distinguishing between
different channels that you might have.)</p><p>To “uninstall” a package, simply remove it from
<code class="option">environment.systemPackages</code> and run
<span class="command"><strong>nixos-rebuild switch</strong></span>.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="sec-customising-packages"></a><a xmlns="" href="#sec-customising-packages">6.1.1. Customising Packages</a></h3></div></div></div><p>Some packages in Nixpkgs have options to enable or disable
optional functionality or change other aspects of the package.  For
instance, the Firefox wrapper package (which provides Firefox with a
set of plugins such as the Adobe Flash player) has an option to enable
the Google Talk plugin.  It can be set in
<code class="filename">configuration.nix</code> as follows:

<code class="filename">
nixpkgs.config.firefox.enableGoogleTalkPlugin = true;
</code>
</p><div class="warning"><h3 class="title">Warning</h3><p>Unfortunately, Nixpkgs currently lacks a way to query
available configuration options.</p></div><p>Apart from high-level options, it’s possible to tweak a package
in almost arbitrary ways, such as changing or disabling dependencies
of a package.  For instance, the Emacs package in Nixpkgs by default
has a dependency on GTK+ 2.  If you want to build it against GTK+ 3,
you can specify that as follows:

</p><pre class="programlisting ">
environment.systemPackages = [ (pkgs.emacs.override { gtk = pkgs.gtk3; }) ];
</pre><p>

The function <code class="varname">override</code> performs the call to the Nix
function that produces Emacs, with the original arguments amended by
the set of arguments specified by you.  So here the function argument
<code class="varname">gtk</code> gets the value <code class="literal">pkgs.gtk3</code>,
causing Emacs to depend on GTK+ 3.  (The parentheses are necessary
because in Nix, function application binds more weakly than list
construction, so without them,
<code class="literal">environment.systemPackages</code> would be a list with two
elements.)</p><p>Even greater customisation is possible using the function
<code class="varname">overrideDerivation</code>.  While the
<code class="varname">override</code> mechanism above overrides the arguments of
a package function, <code class="varname">overrideDerivation</code> allows
changing the <span class="emphasis"><em>result</em></span> of the function.  This
permits changing any aspect of the package, such as the source code.
For instance, if you want to override the source code of Emacs, you
can say:

</p><pre class="programlisting ">
environment.systemPackages =
  [ (pkgs.lib.overrideDerivation pkgs.emacs (attrs: {
      name = "emacs-25.0-pre";
      src = /path/to/my/emacs/tree;
    }))
  ];
</pre><p>

Here, <code class="varname">overrideDerivation</code> takes the Nix derivation
specified by <code class="varname">pkgs.emacs</code> and produces a new
derivation in which the original’s <code class="literal">name</code> and
<code class="literal">src</code> attribute have been replaced by the given
values.  The original attributes are accessible via
<code class="varname">attrs</code>.</p><p>The overrides shown above are not global.  They do not affect
the original package; other packages in Nixpkgs continue to depend on
the original rather than the customised package.  This means that if
another package in your system depends on the original package, you
end up with two instances of the package.  If you want to have
everything depend on your customised instance, you can apply a
<span class="emphasis"><em>global</em></span> override as follows:

</p><pre class="screen ">
nixpkgs.config.packageOverrides = pkgs:
  { emacs = pkgs.emacs.override { gtk = pkgs.gtk3; };
  };
</pre><p>

The effect of this definition is essentially equivalent to modifying
the <code class="literal">emacs</code> attribute in the Nixpkgs source tree.
Any package in Nixpkgs that depends on <code class="literal">emacs</code> will
be passed your customised instance.  (However, the value
<code class="literal">pkgs.emacs</code> in
<code class="varname">nixpkgs.config.packageOverrides</code> refers to the
original rather than overridden instance, to prevent an infinite
recursion.)</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="sec-custom-packages"></a><a xmlns="" href="#sec-custom-packages">6.1.2. Adding Custom Packages</a></h3></div></div></div><p>It’s possible that a package you need is not available in NixOS.
In that case, you can do two things.  First, you can clone the Nixpkgs
repository, add the package to your clone, and (optionally) submit a
patch or pull request to have it accepted into the main Nixpkgs
repository.  This is described in detail in the <a class="link" href="http://nixos.org/nixpkgs/manual" target="_top">Nixpkgs manual</a>.
In short, you clone Nixpkgs:

</p><pre class="screen ">
$ git clone git://github.com/NixOS/nixpkgs.git
$ cd nixpkgs
</pre><p>

Then you write and test the package as described in the Nixpkgs
manual.  Finally, you add it to
<code class="literal">environment.systemPackages</code>, e.g.

</p><pre class="programlisting ">
environment.systemPackages = [ pkgs.my-package ];
</pre><p>

and you run <span class="command"><strong>nixos-rebuild</strong></span>, specifying your own
Nixpkgs tree:

</p><pre class="screen ">
$ nixos-rebuild switch -I nixpkgs=/path/to/my/nixpkgs</pre><p>

</p><p>The second possibility is to add the package outside of the
Nixpkgs tree.  For instance, here is how you specify a build of the
<a class="link" href="http://www.gnu.org/software/hello/" target="_top">GNU Hello</a>
package directly in <code class="filename">configuration.nix</code>:

</p><pre class="programlisting ">
environment.systemPackages =
  let
    my-hello = with pkgs; stdenv.mkDerivation rec {
      name = "hello-2.8";
      src = fetchurl {
        url = "mirror://gnu/hello/${name}.tar.gz";
        sha256 = "0wqd8sjmxfskrflaxywc7gqw7sfawrfvdxd9skxawzfgyy0pzdz6";
      };
    };
  in
  [ my-hello ];
</pre><p>

Of course, you can also move the definition of
<code class="literal">my-hello</code> into a separate Nix expression, e.g.
</p><pre class="programlisting ">
environment.systemPackages = [ (import ./my-hello.nix) ];
</pre><p>
where <code class="filename">my-hello.nix</code> contains:
</p><pre class="programlisting ">
with import &lt;nixpkgs&gt; {}; # bring all of Nixpkgs into scope

stdenv.mkDerivation rec {
  name = "hello-2.8";
  src = fetchurl {
    url = "mirror://gnu/hello/${name}.tar.gz";
    sha256 = "0wqd8sjmxfskrflaxywc7gqw7sfawrfvdxd9skxawzfgyy0pzdz6";
  };
}
</pre><p>

This allows testing the package easily:
</p><pre class="screen ">
$ nix-build my-hello.nix
$ ./result/bin/hello
Hello, world!
</pre><p>

</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-ad-hoc-packages"></a><a xmlns="" href="#sec-ad-hoc-packages">6.2. Ad-Hoc Package Management</a></h2></div></div></div><p>With the command <span class="command"><strong>nix-env</strong></span>, you can install and
uninstall packages from the command line.  For instance, to install
Mozilla Thunderbird:

</p><pre class="screen ">
$ nix-env -iA nixos.pkgs.thunderbird</pre><p>

If you invoke this as root, the package is installed in the Nix
profile <code class="filename">/nix/var/nix/profiles/default</code> and visible
to all users of the system; otherwise, the package ends up in
<code class="filename">/nix/var/nix/profiles/per-user/<em class="replaceable"><code>username</code></em>/profile</code>
and is not visible to other users.  The <code class="option">-A</code> flag
specifies the package by its attribute name; without it, the package
is installed by matching against its package name
(e.g. <code class="literal">thunderbird</code>).  The latter is slower because
it requires matching against all available Nix packages, and is
ambiguous if there are multiple matching packages.</p><p>Packages come from the NixOS channel.  You typically upgrade a
package by updating to the latest version of the NixOS channel:
</p><pre class="screen ">
$ nix-channel --update nixos
</pre><p>
and then running <code class="literal">nix-env -i</code> again.  Other packages
in the profile are <span class="emphasis"><em>not</em></span> affected; this is the
crucial difference with the declarative style of package management,
where running <span class="command"><strong>nixos-rebuild switch</strong></span> causes all
packages to be updated to their current versions in the NixOS channel.
You can however upgrade all packages for which there is a newer
version by doing:
</p><pre class="screen ">
$ nix-env -u '*'
</pre><p>
</p><p>A package can be uninstalled using the <code class="option">-e</code>
flag:
</p><pre class="screen ">
$ nix-env -e thunderbird
</pre><p>
</p><p>Finally, you can roll back an undesirable
<span class="command"><strong>nix-env</strong></span> action:
</p><pre class="screen ">
$ nix-env --rollback
</pre><p>
</p><p><span class="command"><strong>nix-env</strong></span> has many more flags.  For details,
see the
<span class="citerefentry"><span class="refentrytitle">nix-env</span>(1)</span>
manpage or the Nix manual.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-user-management"></a><a xmlns="" href="#sec-user-management">Chapter 7. User Management</a></h2></div></div></div><p>NixOS supports both declarative and imperative styles of user
management.  In the declarative style, users are specified in
<code class="filename">configuration.nix</code>.  For instance, the following
states that a user account named <code class="literal">alice</code> shall exist:

</p><pre class="programlisting ">
users.extraUsers.alice =
  { isNormalUser = true;
    home = "/home/alice";
    description = "Alice Foobar";
    extraGroups = [ "wheel" "networkmanager" ];
    openssh.authorizedKeys.keys = [ "ssh-dss AAAAB3Nza... alice@foobar" ];
  };
</pre><p>

Note that <code class="literal">alice</code> is a member of the
<code class="literal">wheel</code> and <code class="literal">networkmanager</code> groups,
which allows her to use <span class="command"><strong>sudo</strong></span> to execute commands as
<code class="literal">root</code> and to configure the network, respectively.
Also note the SSH public key that allows remote logins with the
corresponding private key. Users created in this way do not have a
password by default, so they cannot log in via mechanisms that require
a password. However, you can use the <span class="command"><strong>passwd</strong></span> program
to set a password, which is retained across invocations of
<span class="command"><strong>nixos-rebuild</strong></span>.</p><p>If you set users.mutableUsers to false, then the contents of /etc/passwd
and /etc/group will be congruent to your NixOS configuration. For instance,
if you remove a user from users.extraUsers and run nixos-rebuild, the user
account will cease to exist. Also, imperative commands for managing users
and groups, such as useradd, are no longer available.</p><p>A user ID (uid) is assigned automatically.  You can also specify
a uid manually by adding

</p><pre class="programlisting ">
    uid = 1000;
</pre><p>

to the user specification.</p><p>Groups can be specified similarly.  The following states that a
group named <code class="literal">students</code> shall exist:

</p><pre class="programlisting ">
users.extraGroups.students.gid = 1000;
</pre><p>

As with users, the group ID (gid) is optional and will be assigned
automatically if it’s missing.</p><p>In the imperative style, users and groups are managed by
commands such as <span class="command"><strong>useradd</strong></span>,
<span class="command"><strong>groupmod</strong></span> and so on.  For instance, to create a user
account named <code class="literal">alice</code>:

</p><pre class="screen ">
$ useradd -m alice</pre><p>

The flag <code class="option">-m</code> causes the creation of a home directory
for the new user, which is generally what you want.  The user does not
have an initial password and therefore cannot log in.  A password can
be set using the <span class="command"><strong>passwd</strong></span> utility:

</p><pre class="screen ">
$ passwd alice
Enter new UNIX password: ***
Retype new UNIX password: ***
</pre><p>

A user can be deleted using <span class="command"><strong>userdel</strong></span>:

</p><pre class="screen ">
$ userdel -r alice</pre><p>

The flag <code class="option">-r</code> deletes the user’s home directory.
Accounts can be modified using <span class="command"><strong>usermod</strong></span>.  Unix
groups can be managed using <span class="command"><strong>groupadd</strong></span>,
<span class="command"><strong>groupmod</strong></span> and <span class="command"><strong>groupdel</strong></span>.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch-file-systems"></a><a xmlns="" href="#ch-file-systems">Chapter 8. File Systems</a></h2></div></div></div><p>You can define file systems using the
<code class="option">fileSystems</code> configuration option.  For instance, the
following definition causes NixOS to mount the Ext4 file system on
device <code class="filename">/dev/disk/by-label/data</code> onto the mount
point <code class="filename">/data</code>:

</p><pre class="programlisting ">
fileSystems."/data" =
  { device = "/dev/disk/by-label/data";
    fsType = "ext4";
  };
</pre><p>

Mount points are created automatically if they don’t already exist.
For <code class="option">device</code>, it’s best to use the topology-independent
device aliases in <code class="filename">/dev/disk/by-label</code> and
<code class="filename">/dev/disk/by-uuid</code>, as these don’t change if the
topology changes (e.g. if a disk is moved to another IDE
controller).</p><p>You can usually omit the file system type
(<code class="option">fsType</code>), since <span class="command"><strong>mount</strong></span> can usually
detect the type and load the necessary kernel module automatically.
However, if the file system is needed at early boot (in the initial
ramdisk) and is not <code class="literal">ext2</code>, <code class="literal">ext3</code>
or <code class="literal">ext4</code>, then it’s best to specify
<code class="option">fsType</code> to ensure that the kernel module is
available.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-luks-file-systems"></a><a xmlns="" href="#sec-luks-file-systems">8.1. LUKS-Encrypted File Systems</a></h2></div></div></div><p>NixOS supports file systems that are encrypted using
<span class="emphasis"><em>LUKS</em></span> (Linux Unified Key Setup).  For example,
here is how you create an encrypted Ext4 file system on the device
<code class="filename">/dev/sda2</code>:

</p><pre class="screen ">
$ cryptsetup luksFormat /dev/sda2

WARNING!
========
This will overwrite data on /dev/sda2 irrevocably.

Are you sure? (Type uppercase yes): YES
Enter LUKS passphrase: ***
Verify passphrase: ***

$ cryptsetup luksOpen /dev/sda2 crypted
Enter passphrase for /dev/sda2: ***

$ mkfs.ext4 /dev/mapper/crypted
</pre><p>

To ensure that this file system is automatically mounted at boot time
as <code class="filename">/</code>, add the following to
<code class="filename">configuration.nix</code>:

</p><pre class="programlisting ">
boot.initrd.luks.devices = [ { device = "/dev/sda2"; name = "crypted"; } ];
fileSystems."/".device = "/dev/mapper/crypted";
</pre><p>

</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-x11"></a><a xmlns="" href="#sec-x11">Chapter 9. X Window System</a></h2></div></div></div><p>The X Window System (X11) provides the basis of NixOS’ graphical
user interface.  It can be enabled as follows:
</p><pre class="programlisting ">
services.xserver.enable = true;
</pre><p>
The X server will automatically detect and use the appropriate video
driver from a set of X.org drivers (such as <code class="literal">vesa</code>
and <code class="literal">intel</code>).  You can also specify a driver
manually, e.g.
</p><pre class="programlisting ">
services.xserver.videoDrivers = [ "r128" ];
</pre><p>
to enable X.org’s <code class="literal">xf86-video-r128</code> driver.</p><p>You also need to enable at least one desktop or window manager.
Otherwise, you can only log into a plain undecorated
<span class="command"><strong>xterm</strong></span> window.  Thus you should pick one or more of
the following lines:
</p><pre class="programlisting ">
services.xserver.desktopManager.kde4.enable = true;
services.xserver.desktopManager.xfce.enable = true;
services.xserver.windowManager.xmonad.enable = true;
services.xserver.windowManager.twm.enable = true;
services.xserver.windowManager.icewm.enable = true;
</pre><p>
</p><p>NixOS’s default <span class="emphasis"><em>display manager</em></span> (the
program that provides a graphical login prompt and manages the X
server) is SLiM.  You can select KDE’s <span class="command"><strong>kdm</strong></span> instead:
</p><pre class="programlisting ">
services.xserver.displayManager.kdm.enable = true;
</pre><p>
</p><p>The X server is started automatically at boot time.  If you
don’t want this to happen, you can set:
</p><pre class="programlisting ">
services.xserver.autorun = false;
</pre><p>
The X server can then be started manually:
</p><pre class="screen ">
$ systemctl start display-manager.service
</pre><p>
</p><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737316658512"></a><a xmlns="" href="#idm140737316658512">NVIDIA Graphics Cards</a></h2></div></div></div><p>NVIDIA provides a proprietary driver for its graphics cards that
has better 3D performance than the X.org drivers.  It is not enabled
by default because it’s not free software.  You can enable it as follows:
</p><pre class="programlisting ">
services.xserver.videoDrivers = [ "nvidia" ];
</pre><p>
You may need to reboot after enabling this driver to prevent a clash
with other kernel modules.</p><p>On 64-bit systems, if you want full acceleration for 32-bit
programs such as Wine, you should also set the following:
</p><pre class="programlisting ">
hardware.opengl.driSupport32Bit = true;
</pre><p>
</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737316655552"></a><a xmlns="" href="#idm140737316655552">AMD Graphics Cards</a></h2></div></div></div><p>AMD provides a proprietary driver for its graphics cards that
has better 3D performance than the X.org drivers.  It is not enabled
by default because it’s not free software.  You can enable it as follows:
</p><pre class="programlisting ">
services.xserver.videoDrivers = [ "ati_unfree" ];
</pre><p>
You will need to reboot after enabling this driver to prevent a clash
with other kernel modules.</p><p>On 64-bit systems, if you want full acceleration for 32-bit
programs such as Wine, you should also set the following:
</p><pre class="programlisting ">
hardware.opengl.driSupport32Bit = true;
</pre><p>
</p></div><div class="simplesect"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737316652592"></a><a xmlns="" href="#idm140737316652592">Touchpads</a></h2></div></div></div><p>Support for Synaptics touchpads (found in many laptops such as
the Dell Latitude series) can be enabled as follows:
</p><pre class="programlisting ">
services.xserver.synaptics.enable = true;
</pre><p>
The driver has many options (see <a class="xref" href="ch-options.html" title="Appendix A. Configuration Options">Appendix A, <em>Configuration Options</em></a>).  For
instance, the following enables two-finger scrolling:
</p><pre class="programlisting ">
services.xserver.synaptics.twoFingerScroll = true;
</pre><p>
</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-networking"></a><a xmlns="" href="#sec-networking">Chapter 10. Networking</a></h2></div></div></div><p>This section describes how to configure networking components on
your NixOS machine.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-networkmanager"></a><a xmlns="" href="#sec-networkmanager">10.1. NetworkManager</a></h2></div></div></div><p>To facilitate network configuration, some desktop environments
use NetworkManager. You can enable NetworkManager by setting:

</p><pre class="programlisting ">
networking.networkmanager.enable = true;
</pre><p>

some desktop managers (e.g., GNOME) enable NetworkManager
automatically for you.</p><p>All users that should have permission to change network settings
must belong to the <code class="code">networkmanager</code> group.</p><div class="note"><h3 class="title">Note</h3><p><code class="code">networking.networkmanager</code> and
<code class="code">networking.wireless</code> can not be enabled at the same time:
you can still connect to the wireless networks using
NetworkManager.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-ssh"></a><a xmlns="" href="#sec-ssh">10.2. Secure Shell Access</a></h2></div></div></div><p>Secure shell (SSH) access to your machine can be enabled by
setting:

</p><pre class="programlisting ">
services.openssh.enable = true;
</pre><p>

By default, root logins using a password are disallowed.  They can be
disabled entirely by setting
<code class="literal">services.openssh.permitRootLogin</code> to
<code class="literal">"no"</code>.</p><p>You can declaratively specify authorised RSA/DSA public keys for
a user as follows:


</p><pre class="programlisting ">
users.extraUsers.alice.openssh.authorizedKeys.keys =
  [ "ssh-dss AAAAB3NzaC1kc3MAAACBAPIkGWVEt4..." ];
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-ipv4"></a><a xmlns="" href="#sec-ipv4">10.3. IPv4 Configuration</a></h2></div></div></div><p>By default, NixOS uses DHCP (specifically,
<span class="command"><strong>dhcpcd</strong></span>) to automatically configure network
interfaces.  However, you can configure an interface manually as
follows:

</p><pre class="programlisting ">
networking.interfaces.eth0.ip4 = [ { address = "192.168.1.2"; prefixLength = 24; } ];
</pre><p>

Typically you’ll also want to set a default gateway and set of name
servers:

</p><pre class="programlisting ">
networking.defaultGateway = "192.168.1.1";
networking.nameservers = [ "8.8.8.8" ];
</pre><p>

</p><div class="note"><h3 class="title">Note</h3><p>Statically configured interfaces are set up by the systemd
service
<em class="replaceable"><code>interface-name</code></em><code class="literal">-cfg.service</code>.
The default gateway and name server configuration is performed by
<code class="literal">network-setup.service</code>.</p></div><p>The host name is set using <code class="option">networking.hostName</code>:

</p><pre class="programlisting ">
networking.hostName = "cartman";
</pre><p>

The default host name is <code class="literal">nixos</code>.  Set it to the
empty string (<code class="literal">""</code>) to allow the DHCP server to
provide the host name.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-ipv6"></a><a xmlns="" href="#sec-ipv6">10.4. IPv6 Configuration</a></h2></div></div></div><p>IPv6 is enabled by default.  Stateless address autoconfiguration
is used to automatically assign IPv6 addresses to all interfaces.  You
can disable IPv6 support globally by setting:

</p><pre class="programlisting ">
networking.enableIPv6 = false;
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-firewall"></a><a xmlns="" href="#sec-firewall">10.5. Firewall</a></h2></div></div></div><p>NixOS has a simple stateful firewall that blocks incoming
connections and other unexpected packets.  The firewall applies to
both IPv4 and IPv6 traffic. It is enabled by default. It can be
disabled as follows:

</p><pre class="programlisting ">
networking.firewall.enable = false;
</pre><p>

If the firewall is enabled, you can open specific TCP ports to the
outside world:

</p><pre class="programlisting ">
networking.firewall.allowedTCPPorts = [ 80 443 ];
</pre><p>

Note that TCP port 22 (ssh) is opened automatically if the SSH daemon
is enabled (<code class="option">services.openssh.enable = true</code>).  UDP
ports can be opened through
<code class="option">networking.firewall.allowedUDPPorts</code>.  Also of
interest is

</p><pre class="programlisting ">
networking.firewall.allowPing = true;
</pre><p>

to allow the machine to respond to ping requests.  (ICMPv6 pings are
always allowed.)</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-wireless"></a><a xmlns="" href="#sec-wireless">10.6. Wireless Networks</a></h2></div></div></div><p>For a desktop installation using NetworkManager (e.g., GNOME),
you just have to make sure the user is in the
<code class="code">networkmanager</code> group and you can skip the rest of this
section on wireless networks.</p><p>
NixOS will start wpa_supplicant for you if you enable this setting:

</p><pre class="programlisting ">
networking.wireless.enable = true;
</pre><p>

NixOS currently does not generate wpa_supplicant's
configuration file, <code class="literal">/etc/wpa_supplicant.conf</code>. You should edit this file
yourself to define wireless networks, WPA keys and so on (see
wpa_supplicant.conf(5)).
</p><p>
If you are using WPA2 the <span class="command"><strong>wpa_passphrase</strong></span> tool might be useful
to generate the <code class="literal">wpa_supplicant.conf</code>.

</p><pre class="screen ">
$ wpa_passphrase ESSID PSK &gt; /etc/wpa_supplicant.conf</pre><p>

After you have edited the <code class="literal">wpa_supplicant.conf</code>,
you need to restart the wpa_supplicant service.

</p><pre class="screen ">
$ systemctl restart wpa_supplicant.service</pre><p>
</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="ad-hoc-network-config"></a><a xmlns="" href="#ad-hoc-network-config">10.7. Ad-Hoc Configuration</a></h2></div></div></div><p>You can use <code class="option">networking.localCommands</code> to specify
shell commands to be run at the end of
<code class="literal">network-setup.service</code>.  This is useful for doing
network configuration not covered by the existing NixOS modules.  For
instance, to statically configure an IPv6 address:

</p><pre class="programlisting nix">
networking.localCommands =
  ''
    ip -6 addr add 2001:610:685:1::1/64 dev eth0
  '';
</pre><p>

</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-kernel-config"></a><a xmlns="" href="#sec-kernel-config">Chapter 11. Linux Kernel</a></h2></div></div></div><p>You can override the Linux kernel and associated packages using
the option <code class="option">boot.kernelPackages</code>.  For instance, this
selects the Linux 3.10 kernel:
</p><pre class="programlisting ">
boot.kernelPackages = pkgs.linuxPackages_3_10;
</pre><p>
Note that this not only replaces the kernel, but also packages that
are specific to the kernel version, such as the NVIDIA video drivers.
This ensures that driver packages are consistent with the
kernel.</p><p>The default Linux kernel configuration should be fine for most users. You can see the configuration of your current kernel with the following command:
</p><pre class="programlisting ">
cat /proc/config.gz | gunzip
</pre><p>
If you want to change the kernel configuration, you can use the
<code class="option">packageOverrides</code> feature (see <a class="xref" href="index.html#sec-customising-packages" title="6.1.1. Customising Packages">Section 6.1.1, “Customising Packages”</a>).  For instance, to enable
support for the kernel debugger KGDB:

</p><pre class="programlisting ">
nixpkgs.config.packageOverrides = pkgs:
  { linux_3_4 = pkgs.linux_3_4.override {
      extraConfig =
        ''
          KGDB y
        '';
    };
  };
</pre><p>

<code class="varname">extraConfig</code> takes a list of Linux kernel
configuration options, one per line.  The name of the option should
not include the prefix <code class="literal">CONFIG_</code>.  The option value
is typically <code class="literal">y</code>, <code class="literal">n</code> or
<code class="literal">m</code> (to build something as a kernel module).</p><p>Kernel modules for hardware devices are generally loaded
automatically by <span class="command"><strong>udev</strong></span>.  You can force a module to
be loaded via <code class="option">boot.kernelModules</code>, e.g.
</p><pre class="programlisting ">
boot.kernelModules = [ "fuse" "kvm-intel" "coretemp" ];
</pre><p>
If the module is required early during the boot (e.g. to mount the
root file system), you can use
<code class="option">boot.initrd.extraKernelModules</code>:
</p><pre class="programlisting ">
boot.initrd.extraKernelModules = [ "cifs" ];
</pre><p>
This causes the specified modules and their dependencies to be added
to the initial ramdisk.</p><p>Kernel runtime parameters can be set through
<code class="option">boot.kernel.sysctl</code>, e.g.
</p><pre class="programlisting nix">
boot.kernel.sysctl."net.ipv4.tcp_keepalive_time" = 120;
</pre><p>
sets the kernel’s TCP keepalive time to 120 seconds.  To see the
available parameters, run <span class="command"><strong>sysctl -a</strong></span>.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="module-postgresql"></a><a xmlns="" href="#module-postgresql">Chapter 12. PostgreSQL</a></h2></div></div></div><p><span class="emphasis"><em>Source:</em></span> <code class="filename">modules/services/databases/postgresql.nix</code></p><p><span class="emphasis"><em>Upstream documentation:</em></span> <a class="link" href="http://www.postgresql.org/docs/" target="_top">http://www.postgresql.org/docs/</a></p><p>PostgreSQL is an advanced, free relational database.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737316585504"></a><a xmlns="" href="#idm140737316585504">12.1. Configuring</a></h2></div></div></div><p>To enable PostgreSQL, add the following to your
<code class="filename">configuration.nix</code>:

</p><pre class="programlisting ">
services.postgresql.enable = true;
services.postgresql.package = pkgs.postgresql94;
</pre><p>

Note that you are required to specify the desired version of
PostgreSQL (e.g. <code class="literal">pkgs.postgresql94</code>). Since
upgrading your PostgreSQL version requires a database dump and reload
(see below), NixOS cannot provide a default value for
<code class="option">services.postgresql.package</code> such as the most recent
release of PostgreSQL.</p><p>By default, PostgreSQL stores its databases in
<code class="filename">/var/db/postgresql</code>. You can override this using
<code class="option">services.postgresql.dataDir</code>, e.g.

</p><pre class="programlisting ">
services.postgresql.dataDir = "/data/postgresql";
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737316579808"></a><a xmlns="" href="#idm140737316579808">12.2. Upgrading</a></h2></div></div></div><p>FIXME: document dump/upgrade/load cycle.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="idm140737316578592"></a><a xmlns="" href="#idm140737316578592">12.3. Options</a></h2></div></div></div><p>FIXME: auto-generated list of module options.</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="title"><a xmlns="http://www.w3.org/1999/xhtml" id="ch-running"></a><a href="#ch-running">Part III. Administration</a></h1></div></div></div><div class="partintro"><div></div><p>This chapter describes various aspects of managing a running
NixOS system, such as how to use the <span class="command"><strong>systemd</strong></span>
service manager.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-systemctl"></a><a xmlns="" href="#sec-systemctl">Chapter 13. Service Management</a></h2></div></div></div><p>In NixOS, all system services are started and monitored using
the systemd program.  Systemd is the “init” process of the system
(i.e. PID 1), the parent of all other processes.  It manages a set of
so-called “units”, which can be things like system services
(programs), but also mount points, swap files, devices, targets
(groups of units) and more.  Units can have complex dependencies; for
instance, one unit can require that another unit must be successfully
started before the first unit can be started.  When the system boots,
it starts a unit named <code class="literal">default.target</code>; the
dependencies of this unit cause all system services to be started,
file systems to be mounted, swap files to be activated, and so
on.</p><p>The command <span class="command"><strong>systemctl</strong></span> is the main way to
interact with <span class="command"><strong>systemd</strong></span>.  Without any arguments, it
shows the status of active units:

</p><pre class="screen ">
$ systemctl
-.mount          loaded active mounted   /
swapfile.swap    loaded active active    /swapfile
sshd.service     loaded active running   SSH Daemon
graphical.target loaded active active    Graphical Interface
<em class="replaceable"><code>...</code></em>
</pre><p>

</p><p>You can ask for detailed status information about a unit, for
instance, the PostgreSQL database service:

</p><pre class="screen ">
$ systemctl status postgresql.service
postgresql.service - PostgreSQL Server
          Loaded: loaded (/nix/store/pn3q73mvh75gsrl8w7fdlfk3fq5qm5mw-unit/postgresql.service)
          Active: active (running) since Mon, 2013-01-07 15:55:57 CET; 9h ago
        Main PID: 2390 (postgres)
          CGroup: name=systemd:/system/postgresql.service
                  ├─2390 postgres
                  ├─2418 postgres: writer process
                  ├─2419 postgres: wal writer process
                  ├─2420 postgres: autovacuum launcher process
                  ├─2421 postgres: stats collector process
                  └─2498 postgres: zabbix zabbix [local] idle

Jan 07 15:55:55 hagbard postgres[2394]: [1-1] LOG:  database system was shut down at 2013-01-07 15:55:05 CET
Jan 07 15:55:57 hagbard postgres[2390]: [1-1] LOG:  database system is ready to accept connections
Jan 07 15:55:57 hagbard postgres[2420]: [1-1] LOG:  autovacuum launcher started
Jan 07 15:55:57 hagbard systemd[1]: Started PostgreSQL Server.
</pre><p>

Note that this shows the status of the unit (active and running), all
the processes belonging to the service, as well as the most recent log
messages from the service.

</p><p>Units can be stopped, started or restarted:

</p><pre class="screen ">
$ systemctl stop postgresql.service
$ systemctl start postgresql.service
$ systemctl restart postgresql.service
</pre><p>

These operations are synchronous: they wait until the service has
finished starting or stopping (or has failed).  Starting a unit will
cause the dependencies of that unit to be started as well (if
necessary).</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-rebooting"></a><a xmlns="" href="#sec-rebooting">Chapter 14. Rebooting and Shutting Down</a></h2></div></div></div><p>The system can be shut down (and automatically powered off) by
doing:

</p><pre class="screen ">
$ shutdown
</pre><p>

This is equivalent to running <span class="command"><strong>systemctl
poweroff</strong></span>.</p><p>To reboot the system, run

</p><pre class="screen ">
$ reboot
</pre><p>

which is equivalent to <span class="command"><strong>systemctl reboot</strong></span>.
Alternatively, you can quickly reboot the system using
<code class="literal">kexec</code>, which bypasses the BIOS by directly loading
the new kernel into memory:

</p><pre class="screen ">
$ systemctl kexec
</pre><p>

</p><p>The machine can be suspended to RAM (if supported) using
<span class="command"><strong>systemctl suspend</strong></span>, and suspended to disk using
<span class="command"><strong>systemctl hibernate</strong></span>.</p><p>These commands can be run by any user who is logged in locally,
i.e. on a virtual console or in X11; otherwise, the user is asked for
authentication.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-user-sessions"></a><a xmlns="" href="#sec-user-sessions">Chapter 15. User Sessions</a></h2></div></div></div><p>Systemd keeps track of all users who are logged into the system
(e.g. on a virtual console or remotely via SSH).  The command
<span class="command"><strong>loginctl</strong></span> allows querying and manipulating user
sessions.  For instance, to list all user sessions:

</p><pre class="screen ">
$ loginctl
   SESSION        UID USER             SEAT
        c1        500 eelco            seat0
        c3          0 root             seat0
        c4        500 alice
</pre><p>

This shows that two users are logged in locally, while another is
logged in remotely.  (“Seats” are essentially the combinations of
displays and input devices attached to the system; usually, there is
only one seat.)  To get information about a session:

</p><pre class="screen ">
$ loginctl session-status c3
c3 - root (0)
           Since: Tue, 2013-01-08 01:17:56 CET; 4min 42s ago
          Leader: 2536 (login)
            Seat: seat0; vc3
             TTY: /dev/tty3
         Service: login; type tty; class user
           State: online
          CGroup: name=systemd:/user/root/c3
                  ├─ 2536 /nix/store/10mn4xip9n7y9bxqwnsx7xwx2v2g34xn-shadow-4.1.5.1/bin/login --
                  ├─10339 -bash
                  └─10355 w3m nixos.org
</pre><p>

This shows that the user is logged in on virtual console 3.  It also
lists the processes belonging to this session.  Since systemd keeps
track of this, you can terminate a session in a way that ensures that
all the session’s processes are gone:

</p><pre class="screen ">
$ loginctl terminate-session c3
</pre><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-cgroups"></a><a xmlns="" href="#sec-cgroups">Chapter 16. Control Groups</a></h2></div></div></div><p>To keep track of the processes in a running system, systemd uses
<span class="emphasis"><em>control groups</em></span> (cgroups).  A control group is a
set of processes used to allocate resources such as CPU, memory or I/O
bandwidth.  There can be multiple control group hierarchies, allowing
each kind of resource to be managed independently.</p><p>The command <span class="command"><strong>systemd-cgls</strong></span> lists all control
groups in the <code class="literal">systemd</code> hierarchy, which is what
systemd uses to keep track of the processes belonging to each service
or user session:

</p><pre class="screen ">
$ systemd-cgls
├─user
│ └─eelco
│   └─c1
│     ├─ 2567 -:0
│     ├─ 2682 kdeinit4: kdeinit4 Running...
│     ├─ <em class="replaceable"><code>...</code></em>
│     └─10851 sh -c less -R
└─system
  ├─httpd.service
  │ ├─2444 httpd -f /nix/store/3pyacby5cpr55a03qwbnndizpciwq161-httpd.conf -DNO_DETACH
  │ └─<em class="replaceable"><code>...</code></em>
  ├─dhcpcd.service
  │ └─2376 dhcpcd --config /nix/store/f8dif8dsi2yaa70n03xir8r653776ka6-dhcpcd.conf
  └─ <em class="replaceable"><code>...</code></em>
</pre><p>

Similarly, <span class="command"><strong>systemd-cgls cpu</strong></span> shows the cgroups in
the CPU hierarchy, which allows per-cgroup CPU scheduling priorities.
By default, every systemd service gets its own CPU cgroup, while all
user sessions are in the top-level CPU cgroup.  This ensures, for
instance, that a thousand run-away processes in the
<code class="literal">httpd.service</code> cgroup cannot starve the CPU for one
process in the <code class="literal">postgresql.service</code> cgroup.  (By
contrast, it they were in the same cgroup, then the PostgreSQL process
would get 1/1001 of the cgroup’s CPU time.)  You can limit a service’s
CPU share in <code class="filename">configuration.nix</code>:

</p><pre class="programlisting ">
systemd.services.httpd.serviceConfig.CPUShares = 512;
</pre><p>

By default, every cgroup has 1024 CPU shares, so this will halve the
CPU allocation of the <code class="literal">httpd.service</code> cgroup.</p><p>There also is a <code class="literal">memory</code> hierarchy that
controls memory allocation limits; by default, all processes are in
the top-level cgroup, so any service or session can exhaust all
available memory.  Per-cgroup memory limits can be specified in
<code class="filename">configuration.nix</code>; for instance, to limit
<code class="literal">httpd.service</code> to 512 MiB of RAM (excluding swap):

</p><pre class="programlisting ">
systemd.services.httpd.serviceConfig.MemoryLimit = "512M";
</pre><p>

</p><p>The command <span class="command"><strong>systemd-cgtop</strong></span> shows a
continuously updated list of all cgroups with their CPU and memory
usage.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-logging"></a><a xmlns="" href="#sec-logging">Chapter 17. Logging</a></h2></div></div></div><p>System-wide logging is provided by systemd’s
<span class="emphasis"><em>journal</em></span>, which subsumes traditional logging
daemons such as syslogd and klogd.  Log entries are kept in binary
files in <code class="filename">/var/log/journal/</code>.  The command
<code class="literal">journalctl</code> allows you to see the contents of the
journal.  For example,

</p><pre class="screen ">
$ journalctl -b
</pre><p>

shows all journal entries since the last reboot.  (The output of
<span class="command"><strong>journalctl</strong></span> is piped into <span class="command"><strong>less</strong></span> by
default.)  You can use various options and match operators to restrict
output to messages of interest.  For instance, to get all messages
from PostgreSQL:

</p><pre class="screen ">
$ journalctl -u postgresql.service
-- Logs begin at Mon, 2013-01-07 13:28:01 CET, end at Tue, 2013-01-08 01:09:57 CET. --
...
Jan 07 15:44:14 hagbard postgres[2681]: [2-1] LOG:  database system is shut down
-- Reboot --
Jan 07 15:45:10 hagbard postgres[2532]: [1-1] LOG:  database system was shut down at 2013-01-07 15:44:14 CET
Jan 07 15:45:13 hagbard postgres[2500]: [1-1] LOG:  database system is ready to accept connections
</pre><p>

Or to get all messages since the last reboot that have at least a
“critical” severity level:

</p><pre class="screen ">
$ journalctl -b -p crit
Dec 17 21:08:06 mandark sudo[3673]: pam_unix(sudo:auth): auth could not identify password for [alice]
Dec 29 01:30:22 mandark kernel[6131]: [1053513.909444] CPU6: Core temperature above threshold, cpu clock throttled (total events = 1)
</pre><p>

</p><p>The system journal is readable by root and by users in the
<code class="literal">wheel</code> and <code class="literal">systemd-journal</code>
groups.  All users have a private journal that can be read using
<span class="command"><strong>journalctl</strong></span>.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-nix-gc"></a><a xmlns="" href="#sec-nix-gc">Chapter 18. Cleaning the Nix Store</a></h2></div></div></div><p>Nix has a purely functional model, meaning that packages are
never upgraded in place.  Instead new versions of packages end up in a
different location in the Nix store (<code class="filename">/nix/store</code>).
You should periodically run Nix’s <span class="emphasis"><em>garbage
collector</em></span> to remove old, unreferenced packages.  This is
easy:

</p><pre class="screen ">
$ nix-collect-garbage
</pre><p>

Alternatively, you can use a systemd unit that does the same in the
background:

</p><pre class="screen ">
$ systemctl start nix-gc.service
</pre><p>

You can tell NixOS in <code class="filename">configuration.nix</code> to run
this unit automatically at certain points in time, for instance, every
night at 03:15:

</p><pre class="programlisting ">
nix.gc.automatic = true;
nix.gc.dates = "03:15";
</pre><p>

</p><p>The commands above do not remove garbage collector roots, such
as old system configurations.  Thus they do not remove the ability to
roll back to previous configurations.  The following command deletes
old roots, removing the ability to roll back to them:
</p><pre class="screen ">
$ nix-collect-garbage -d
</pre><p>
You can also do this for specific profiles, e.g.
</p><pre class="screen ">
$ nix-env -p /nix/var/nix/profiles/per-user/eelco/profile --delete-generations old
</pre><p>
Note that NixOS system configurations are stored in the profile
<code class="filename">/nix/var/nix/profiles/system</code>.</p><p>Another way to reclaim disk space (often as much as 40% of the
size of the Nix store) is to run Nix’s store optimiser, which seeks
out identical files in the store and replaces them with hard links to
a single copy.
</p><pre class="screen ">
$ nix-store --optimise
</pre><p>
Since this command needs to read the entire Nix store, it can take
quite a while to finish.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch-containers"></a><a xmlns="" href="#ch-containers">Chapter 19. Container Management</a></h2></div></div></div><p>NixOS allows you to easily run other NixOS instances as
<span class="emphasis"><em>containers</em></span>. Containers are a light-weight
approach to virtualisation that runs software in the container at the
same speed as in the host system. NixOS containers share the Nix store
of the host, making container creation very efficient.</p><div class="warning"><h3 class="title">Warning</h3><p>Currently, NixOS containers are not perfectly isolated
from the host system. This means that a user with root access to the
container can do things that affect the host. So you should not give
container root access to untrusted users.</p></div><p>NixOS containers can be created in two ways: imperatively, using
the command <span class="command"><strong>nixos-container</strong></span>, and declaratively, by
specifying them in your <code class="filename">configuration.nix</code>. The
declarative approach implies that containers get upgraded along with
your host system when you run <span class="command"><strong>nixos-rebuild</strong></span>, which
is often not what you want. By contrast, in the imperative approach,
containers are configured and updated independently from the host
system.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-imperative-containers"></a><a xmlns="" href="#sec-imperative-containers">19.1. Imperative Container Management</a></h2></div></div></div><p>We’ll cover imperative container management using
<span class="command"><strong>nixos-container</strong></span> first. You create a container with
identifier <code class="literal">foo</code> as follows:

</p><pre class="screen ">
$ nixos-container create foo
</pre><p>

This creates the container’s root directory in
<code class="filename">/var/lib/containers/foo</code> and a small configuration
file in <code class="filename">/etc/containers/foo.conf</code>. It also builds
the container’s initial system configuration and stores it in
<code class="filename">/nix/var/nix/profiles/per-container/foo/system</code>. You
can modify the initial configuration of the container on the command
line. For instance, to create a container that has
<span class="command"><strong>sshd</strong></span> running, with the given public key for
<code class="literal">root</code>:

</p><pre class="screen ">
$ nixos-container create foo --config 'services.openssh.enable = true; \
  users.extraUsers.root.openssh.authorizedKeys.keys = ["ssh-dss AAAAB3N…"];'
</pre><p>

</p><p>Creating a container does not start it. To start the container,
run:

</p><pre class="screen ">
$ nixos-container start foo
</pre><p>

This command will return as soon as the container has booted and has
reached <code class="literal">multi-user.target</code>. On the host, the
container runs within a systemd unit called
<code class="literal">container@<em class="replaceable"><code>container-name</code></em>.service</code>.
Thus, if something went wrong, you can get status info using
<span class="command"><strong>systemctl</strong></span>:

</p><pre class="screen ">
$ systemctl status container@foo
</pre><p>

</p><p>If the container has started succesfully, you can log in as
root using the <span class="command"><strong>root-login</strong></span> operation:

</p><pre class="screen ">
$ nixos-container root-login foo
[root@foo:~]#
</pre><p>

Note that only root on the host can do this (since there is no
authentication).  You can also get a regular login prompt using the
<span class="command"><strong>login</strong></span> operation, which is available to all users on
the host:

</p><pre class="screen ">
$ nixos-container login foo
foo login: alice
Password: ***
</pre><p>

With <span class="command"><strong>nixos-container run</strong></span>, you can execute arbitrary
commands in the container:

</p><pre class="screen ">
$ nixos-container run foo -- uname -a
Linux foo 3.4.82 #1-NixOS SMP Thu Mar 20 14:44:05 UTC 2014 x86_64 GNU/Linux
</pre><p>

</p><p>There are several ways to change the configuration of the
container. First, on the host, you can edit
<code class="literal">/var/lib/container/<em class="replaceable"><code>name</code></em>/etc/nixos/configuration.nix</code>,
and run

</p><pre class="screen ">
$ nixos-container update foo
</pre><p>

This will build and activate the new configuration. You can also
specify a new configuration on the command line:

</p><pre class="screen ">
$ nixos-container update foo --config 'services.httpd.enable = true; \
  services.httpd.adminAddr = "foo@example.org";'

$ curl http://$(nixos-container show-ip foo)/
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN"&gt;…
</pre><p>

However, note that this will overwrite the container’s
<code class="filename">/etc/nixos/configuration.nix</code>.</p><p>Alternatively, you can change the configuration from within the
container itself by running <span class="command"><strong>nixos-rebuild switch</strong></span>
inside the container. Note that the container by default does not have
a copy of the NixOS channel, so you should run <span class="command"><strong>nix-channel
--update</strong></span> first.</p><p>Containers can be stopped and started using
<code class="literal">nixos-container stop</code> and <code class="literal">nixos-container
start</code>, respectively, or by using
<span class="command"><strong>systemctl</strong></span> on the container’s service unit. To
destroy a container, including its file system, do

</p><pre class="screen ">
$ nixos-container destroy foo
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-declarative-containers"></a><a xmlns="" href="#sec-declarative-containers">19.2. Declarative Container Specification</a></h2></div></div></div><p>You can also specify containers and their configuration in the
host’s <code class="filename">configuration.nix</code>.  For example, the
following specifies that there shall be a container named
<code class="literal">database</code> running PostgreSQL:

</p><pre class="programlisting ">
containers.database =
  { config =
      { config, pkgs, ... }:
      { services.postgresql.enable = true;
        services.postgresql.package = pkgs.postgresql92;
      };
  };
</pre><p>

If you run <code class="literal">nixos-rebuild switch</code>, the container will
be built and started. If the container was already running, it will be
updated in place, without rebooting.</p><p>By default, declarative containers share the network namespace
of the host, meaning that they can listen on (privileged)
ports. However, they cannot change the network configuration. You can
give a container its own network as follows:

</p><pre class="programlisting ">
containers.database =
  { privateNetwork = true;
    hostAddress = "192.168.100.10";
    localAddress = "192.168.100.11";
  };
</pre><p>

This gives the container a private virtual Ethernet interface with IP
address <code class="literal">192.168.100.11</code>, which is hooked up to a
virtual Ethernet interface on the host with IP address
<code class="literal">192.168.100.10</code>.  (See the next section for details
on container networking.)</p><p>To disable the container, just remove it from
<code class="filename">configuration.nix</code> and run <code class="literal">nixos-rebuild
switch</code>. Note that this will not delete the root directory of
the container in <code class="literal">/var/lib/containers</code>.</p><p>Declarative containers can be started and stopped using the
corresponding systemd service, e.g. <code class="literal">systemctl start
container@database</code>.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-container-networking"></a><a xmlns="" href="#sec-container-networking">19.3. Container Networking</a></h2></div></div></div><p>When you create a container using <code class="literal">nixos-container
create</code>, it gets it own private IPv4 address in the range
<code class="literal">10.233.0.0/16</code>. You can get the container’s IPv4
address as follows:

</p><pre class="screen ">
$ nixos-container show-ip foo
10.233.4.2

$ ping -c1 10.233.4.2
64 bytes from 10.233.4.2: icmp_seq=1 ttl=64 time=0.106 ms
</pre><p>

</p><p>Networking is implemented using a pair of virtual Ethernet
devices. The network interface in the container is called
<code class="literal">eth0</code>, while the matching interface in the host is
called <code class="literal">ve-<em class="replaceable"><code>container-name</code></em></code>
(e.g., <code class="literal">ve-foo</code>).  The container has its own network
namespace and the <code class="literal">CAP_NET_ADMIN</code> capability, so it
can perform arbitrary network configuration such as setting up
firewall rules, without affecting or having access to the host’s
network.</p><p>By default, containers cannot talk to the outside network. If
you want that, you should set up Network Address Translation (NAT)
rules on the host to rewrite container traffic to use your external
IP address. This can be accomplished using the following configuration
on the host:

</p><pre class="programlisting ">
networking.nat.enable = true;
networking.nat.internalInterfaces = ["ve-+"];
networking.nat.externalInterface = "eth0";
</pre><p>
where <code class="literal">eth0</code> should be replaced with the desired
external interface. Note that <code class="literal">ve-+</code> is a wildcard
that matches all container interfaces.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch-troubleshooting"></a><a xmlns="" href="#ch-troubleshooting">Chapter 20. Troubleshooting</a></h2></div></div></div><p>This chapter describes solutions to common problems you might
encounter when you manage your NixOS system.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-boot-problems"></a><a xmlns="" href="#sec-boot-problems">20.1. Boot Problems</a></h2></div></div></div><p>If NixOS fails to boot, there are a number of kernel command
line parameters that may help you to identify or fix the issue.  You
can add these parameters in the GRUB boot menu by pressing “e” to
modify the selected boot entry and editing the line starting with
<code class="literal">linux</code>.  The following are some useful kernel command
line parameters that are recognised by the NixOS boot scripts or by
systemd:

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="literal">boot.shell_on_fail</code></span></dt><dd><p>Start a root shell if something goes wrong in
    stage 1 of the boot process (the initial ramdisk).  This is
    disabled by default because there is no authentication for the
    root shell.</p></dd><dt><span class="term"><code class="literal">boot.debug1</code></span></dt><dd><p>Start an interactive shell in stage 1 before
    anything useful has been done.  That is, no modules have been
    loaded and no file systems have been mounted, except for
    <code class="filename">/proc</code> and
    <code class="filename">/sys</code>.</p></dd><dt><span class="term"><code class="literal">boot.trace</code></span></dt><dd><p>Print every shell command executed by the stage 1
    and 2 boot scripts.</p></dd><dt><span class="term"><code class="literal">single</code></span></dt><dd><p>Boot into rescue mode (a.k.a. single user mode).
    This will cause systemd to start nothing but the unit
    <code class="literal">rescue.target</code>, which runs
    <span class="command"><strong>sulogin</strong></span> to prompt for the root password and
    start a root login shell.  Exiting the shell causes the system to
    continue with the normal boot process.</p></dd><dt><span class="term"><code class="literal">systemd.log_level=debug systemd.log_target=console</code></span></dt><dd><p>Make systemd very verbose and send log messages to
    the console instead of the journal.</p></dd></dl></div><p>

For more parameters recognised by systemd, see
<span class="citerefentry"><span class="refentrytitle">systemd</span>(1)</span>.</p><p>If no login prompts or X11 login screens appear (e.g. due to
hanging dependencies), you can press Alt+ArrowUp.  If you’re lucky,
this will start rescue mode (described above).  (Also note that since
most units have a 90-second timeout before systemd gives up on them,
the <span class="command"><strong>agetty</strong></span> login prompts should appear eventually
unless something is very wrong.)</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-maintenance-mode"></a><a xmlns="" href="#sec-maintenance-mode">20.2. Maintenance Mode</a></h2></div></div></div><p>You can enter rescue mode by running:

</p><pre class="screen ">
$ systemctl rescue</pre><p>

This will eventually give you a single-user root shell.  Systemd will
stop (almost) all system services.  To get out of maintenance mode,
just exit from the rescue shell.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-rollback"></a><a xmlns="" href="#sec-rollback">20.3. Rolling Back Configuration Changes</a></h2></div></div></div><p>After running <span class="command"><strong>nixos-rebuild</strong></span> to switch to a
new configuration, you may find that the new configuration doesn’t
work very well.  In that case, there are several ways to return to a
previous configuration.</p><p>First, the GRUB boot manager allows you to boot into any
previous configuration that hasn’t been garbage-collected.  These
configurations can be found under the GRUB submenu “NixOS - All
configurations”.  This is especially useful if the new configuration
fails to boot.  After the system has booted, you can make the selected
configuration the default for subsequent boots:

</p><pre class="screen ">
$ /run/current-system/bin/switch-to-configuration boot</pre><p>

</p><p>Second, you can switch to the previous configuration in a running
system:

</p><pre class="screen ">
$ nixos-rebuild switch --rollback</pre><p>

This is equivalent to running:

</p><pre class="screen ">
$ /nix/var/nix/profiles/system-<em class="replaceable"><code>N</code></em>-link/bin/switch-to-configuration switch</pre><p>

where <em class="replaceable"><code>N</code></em> is the number of the NixOS system
configuration.  To get a list of the available configurations, do:

</p><pre class="screen ">
$ ls -l /nix/var/nix/profiles/system-*-link
<em class="replaceable"><code>...</code></em>
lrwxrwxrwx 1 root root 78 Aug 12 13:54 /nix/var/nix/profiles/system-268-link -&gt; /nix/store/202b...-nixos-13.07pre4932_5a676e4-4be1055
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-nix-store-corruption"></a><a xmlns="" href="#sec-nix-store-corruption">20.4. Nix Store Corruption</a></h2></div></div></div><p>After a system crash, it’s possible for files in the Nix store
to become corrupted.  (For instance, the Ext4 file system has the
tendency to replace un-synced files with zero bytes.)  NixOS tries
hard to prevent this from happening: it performs a
<span class="command"><strong>sync</strong></span> before switching to a new configuration, and
Nix’s database is fully transactional.  If corruption still occurs,
you may be able to fix it automatically.</p><p>If the corruption is in a path in the closure of the NixOS
system configuration, you can fix it by doing

</p><pre class="screen ">
$ nixos-rebuild switch --repair
</pre><p>

This will cause Nix to check every path in the closure, and if its
cryptographic hash differs from the hash recorded in Nix’s database,
the path is rebuilt or redownloaded.</p><p>You can also scan the entire Nix store for corrupt paths:

</p><pre class="screen ">
$ nix-store --verify --check-contents --repair
</pre><p>

Any corrupt paths will be redownloaded if they’re available in a
binary cache; otherwise, they cannot be repaired.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-nix-network-issues"></a><a xmlns="" href="#sec-nix-network-issues">20.5. Network Problems</a></h2></div></div></div><p>Nix uses a so-called <span class="emphasis"><em>binary cache</em></span> to
optimise building a package from source into downloading it as a
pre-built binary.  That is, whenever a command like
<span class="command"><strong>nixos-rebuild</strong></span> needs a path in the Nix store, Nix
will try to download that path from the Internet rather than build it
from source.  The default binary cache is
<code class="uri">https://cache.nixos.org/</code>.  If this cache is unreachable,
Nix operations may take a long time due to HTTP connection timeouts.
You can disable the use of the binary cache by adding <code class="option">--option
use-binary-caches false</code>, e.g.

</p><pre class="screen ">
$ nixos-rebuild switch --option use-binary-caches false
</pre><p>

If you have an alternative binary cache at your disposal, you can use
it instead:

</p><pre class="screen ">
$ nixos-rebuild switch --option binary-caches http://my-cache.example.org/
</pre><p>

</p></div></div></div><div class="part"><div class="titlepage"><div><div><h1 xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="title"><a xmlns="http://www.w3.org/1999/xhtml" id="ch-development"></a><a href="#ch-development">Part IV. Development</a></h1></div></div></div><div class="partintro"><div></div><p>This chapter describes how you can modify and extend
NixOS.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-getting-sources"></a><a xmlns="" href="#sec-getting-sources">Chapter 21. Getting the Sources</a></h2></div></div></div><p>By default, NixOS’s <span class="command"><strong>nixos-rebuild</strong></span> command
uses the NixOS and Nixpkgs sources provided by the
<code class="literal">nixos-unstable</code> channel (kept in
<code class="filename">/nix/var/nix/profiles/per-user/root/channels/nixos</code>).
To modify NixOS, however, you should check out the latest sources from
Git.  This is done using the following command:

</p><pre class="screen ">
$ nixos-checkout <em class="replaceable"><code>/my/sources</code></em>
</pre><p>

or

</p><pre class="screen ">
$ mkdir -p <em class="replaceable"><code>/my/sources</code></em>
$ cd <em class="replaceable"><code>/my/sources</code></em>
$ nix-env -i git
$ git clone git://github.com/NixOS/nixpkgs.git
</pre><p>

This will check out the latest NixOS sources to
<code class="filename"><em class="replaceable"><code>/my/sources</code></em>/nixpkgs/nixos</code>
and the Nixpkgs sources to
<code class="filename"><em class="replaceable"><code>/my/sources</code></em>/nixpkgs</code>.
(The NixOS source tree lives in a subdirectory of the Nixpkgs
repository.)</p><p>It’s often inconvenient to develop directly on the master
branch, since if somebody has just committed (say) a change to GCC,
then the binary cache may not have caught up yet and you’ll have to
rebuild everything from source. So you may want to create a local
branch based on your current NixOS version:

</p><pre class="screen ">
$ <em class="replaceable"><code>/my/sources</code></em>/nixpkgs/maintainers/scripts/update-channel-branches.sh
Fetching channels from https://nixos.org/channels:
 * [new branch]      cbe467e           -&gt; channels/remotes/nixos-unstable
Fetching channels from nixos-version:
 * [new branch]      9ff4738           -&gt; channels/current-system
Fetching channels from ~/.nix-defexpr:
 * [new branch]      0d4acad           -&gt; channels/root/nixos
$ git checkout -b local channels/current-system
</pre><p>

Or, to base your local branch on the latest version available in the
NixOS channel:

</p><pre class="screen ">
$ <em class="replaceable"><code>/my/sources</code></em>/nixpkgs/maintainers/scripts/update-channel-branches.sh
$ git checkout -b local channels/remotes/nixos-unstable
</pre><p>

You can then use <span class="command"><strong>git rebase</strong></span> to sync your local
branch with the upstream branch, and use <span class="command"><strong>git
cherry-pick</strong></span> to copy commits from your local branch to the
upstream branch.</p><p>If you want to rebuild your system using your (modified)
sources, you need to tell <span class="command"><strong>nixos-rebuild</strong></span> about them
using the <code class="option">-I</code> flag:

</p><pre class="screen ">
$ nixos-rebuild switch -I nixpkgs=<em class="replaceable"><code>/my/sources</code></em>/nixpkgs
</pre><p>

</p><p>If you want <span class="command"><strong>nix-env</strong></span> to use the expressions in
<em class="replaceable"><code>/my/sources</code></em>, use <span class="command"><strong>nix-env -f
<em class="replaceable"><code>/my/sources</code></em>/nixpkgs</strong></span>, or change
the default by adding a symlink in
<code class="filename">~/.nix-defexpr</code>:

</p><pre class="screen ">
$ ln -s <em class="replaceable"><code>/my/sources</code></em>/nixpkgs ~/.nix-defexpr/nixpkgs
</pre><p>

You may want to delete the symlink
<code class="filename">~/.nix-defexpr/channels_root</code> to prevent root’s
NixOS channel from clashing with your own tree.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-writing-modules"></a><a xmlns="" href="#sec-writing-modules">Chapter 22. Writing NixOS Modules</a></h2></div></div></div><p>NixOS has a modular system for declarative configuration.  This
system combines multiple <span class="emphasis"><em>modules</em></span> to produce the
full system configuration.  One of the modules that constitute the
configuration is <code class="filename">/etc/nixos/configuration.nix</code>.
Most of the others live in the <a class="link" href="https://github.com/NixOS/nixpkgs/tree/master/nixos/modules" target="_top"><code class="filename">nixos/modules</code></a>
subdirectory of the Nixpkgs tree.</p><p>Each NixOS module is a file that handles one logical aspect of
the configuration, such as a specific kind of hardware, a service, or
network settings.  A module configuration does not have to handle
everything from scratch; it can use the functionality provided by
other modules for its implementation.  Thus a module can
<span class="emphasis"><em>declare</em></span> options that can be used by other
modules, and conversely can <span class="emphasis"><em>define</em></span> options
provided by other modules in its own implementation.  For example, the
module <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/security/pam.nix" target="_top"><code class="filename">pam.nix</code></a>
declares the option <code class="option">security.pam.services</code> that allows
other modules (e.g. <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/services/networking/ssh/sshd.nix" target="_top"><code class="filename">sshd.nix</code></a>)
to define PAM services; and it defines the option
<code class="option">environment.etc</code> (declared by <a class="link" href="https://github.com/NixOS/nixpkgs/blob/master/nixos/modules/system/etc/etc.nix" target="_top"><code class="filename">etc.nix</code></a>)
to cause files to be created in
<code class="filename">/etc/pam.d</code>.</p><p><a id="para-module-syn"></a>In <a class="xref" href="index.html#sec-configuration-syntax" title="Chapter 5. Configuration Syntax">Chapter 5, <em>Configuration Syntax</em></a>, we saw the following structure
of NixOS modules:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ <em class="replaceable"><code>option definitions</code></em>
}
</pre><p>

This is actually an <span class="emphasis"><em>abbreviated</em></span> form of module
that only defines options, but does not declare any.  The structure of
full NixOS modules is shown in <a class="xref" href="index.html#ex-module-syntax" title="Example 22.1. Structure of NixOS Modules">Example 22.1, “Structure of NixOS Modules”</a>.</p><div class="example"><a id="ex-module-syntax"></a><p class="title"><strong>Example 22.1. Structure of NixOS Modules</strong></p><div class="example-contents"><pre class="programlisting ">
{ config, pkgs, ... }: <a id="module-syntax-1"></a><span><img src="images/callouts/1.gif" alt="1" border="0" /></span>

{
  imports =
    [ <em class="replaceable"><code>paths of other modules</code></em> <a id="module-syntax-2"></a><span><img src="images/callouts/2.gif" alt="2" border="0" /></span>
    ];

  options = {
    <em class="replaceable"><code>option declarations</code></em> <a id="module-syntax-3"></a><span><img src="images/callouts/3.gif" alt="3" border="0" /></span>
  };

  config = {
    <em class="replaceable"><code>option definitions</code></em> <a id="module-syntax-4"></a><span><img src="images/callouts/4.gif" alt="4" border="0" /></span>
  };
}</pre></div></div><br class="example-break" /><p>The meaning of each part is as follows.

</p><div class="calloutlist"><table border="0" summary="Callout list"><tr><td width="5%" valign="top" align="left"><p><a href="#module-syntax-1"><span><img src="images/callouts/1.gif" alt="1" border="0" /></span></a> </p></td><td valign="top" align="left"><p>This line makes the current Nix expression a function.  The
    variable <code class="varname">pkgs</code> contains Nixpkgs, while
    <code class="varname">config</code> contains the full system configuration.
    This line can be omitted if there is no reference to
    <code class="varname">pkgs</code> and <code class="varname">config</code> inside the
    module.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#module-syntax-2"><span><img src="images/callouts/2.gif" alt="2" border="0" /></span></a> </p></td><td valign="top" align="left"><p>This list enumerates the paths to other NixOS modules that
    should be included in the evaluation of the system configuration.
    A default set of modules is defined in the file
    <code class="filename">modules/module-list.nix</code>.  These don't need to
    be added in the import list.</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#module-syntax-3"><span><img src="images/callouts/3.gif" alt="3" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The attribute <code class="varname">options</code> is a nested set of
    <span class="emphasis"><em>option declarations</em></span> (described below).</p></td></tr><tr><td width="5%" valign="top" align="left"><p><a href="#module-syntax-4"><span><img src="images/callouts/4.gif" alt="4" border="0" /></span></a> </p></td><td valign="top" align="left"><p>The attribute <code class="varname">config</code> is a nested set of
    <span class="emphasis"><em>option definitions</em></span> (also described
    below).</p></td></tr></table></div><p>

</p><p><a class="xref" href="index.html#locate-example" title="Example 22.2. NixOS Module for the “locate” Service">Example 22.2, “NixOS Module for the “locate” Service”</a> shows a module that handles
the regular update of the “locate” database, an index of all files in
the file system.  This module declares two options that can be defined
by other modules (typically the user’s
<code class="filename">configuration.nix</code>):
<code class="option">services.locate.enable</code> (whether the database should
be updated) and <code class="option">services.locate.period</code> (when the
update should be done).  It implements its functionality by defining
two options declared by other modules:
<code class="option">systemd.services</code> (the set of all systemd services)
and <code class="option">services.cron.systemCronJobs</code> (the list of
commands to be executed periodically by <span class="command"><strong>cron</strong></span>).</p><div class="example"><a id="locate-example"></a><p class="title"><strong>Example 22.2. NixOS Module for the “locate” Service</strong></p><div class="example-contents"><pre class="programlisting ">
{ config, lib, pkgs, ... }:

with lib;

let locatedb = "/var/cache/locatedb"; in

{
  options = {

    services.locate = {

      enable = mkOption {
        type = types.bool;
        default = false;
        description = ''
          If enabled, NixOS will periodically update the database of
          files used by the <span class="command"><strong>locate</strong></span> command.
        '';
      };

      period = mkOption {
        type = types.str;
        default = "15 02 * * *";
        description = ''
          This option defines (in the format used by cron) when the
          locate database is updated.  The default is to update at
          02:15 at night every day.
        '';
      };

    };

  };

  config = {

    systemd.services.update-locatedb =
      { description = "Update Locate Database";
        path  = [ pkgs.su ];
        script =
          ''
            mkdir -m 0755 -p $(dirname ${locatedb})
            exec updatedb --localuser=nobody --output=${locatedb} --prunepaths='/tmp /var/tmp /media /run'
          '';
      };

    services.cron.systemCronJobs = optional config.services.locate.enable
      "${config.services.locate.period} root ${config.systemd.package}/bin/systemctl start update-locatedb.service";

  };
}</pre></div></div><br class="example-break" /><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-option-declarations"></a><a xmlns="" href="#sec-option-declarations">22.1. Option Declarations</a></h2></div></div></div><p>An option declaration specifies the name, type and description
of a NixOS configuration option.  It is illegal to define an option
that hasn’t been declared in any module.  A option declaration
generally looks like this:

</p><pre class="programlisting ">
options = {
  <em class="replaceable"><code>name</code></em> = mkOption {
    type = <em class="replaceable"><code>type specification</code></em>;
    default = <em class="replaceable"><code>default value</code></em>;
    example = <em class="replaceable"><code>example value</code></em>;
    description = "<em class="replaceable"><code>Description for use in the NixOS manual.</code></em>";
  };
};
</pre><p>

</p><p>The function <code class="varname">mkOption</code> accepts the following arguments.

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">type</code></span></dt><dd><p>The type of the option (see below).  It may be omitted,
      but that’s not advisable since it may lead to errors that are
      hard to diagnose.</p></dd><dt><span class="term"><code class="varname">default</code></span></dt><dd><p>The default value used if no value is defined by any
      module.  A default is not required; in that case, if the option
      value is ever used, an error will be thrown.</p></dd><dt><span class="term"><code class="varname">example</code></span></dt><dd><p>An example value that will be shown in the NixOS manual.</p></dd><dt><span class="term"><code class="varname">description</code></span></dt><dd><p>A textual description of the option, in DocBook format,
      that will be included in the NixOS manual.</p></dd></dl></div><p>

</p><p>Here is a non-exhaustive list of option types:

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">types.bool</code></span></dt><dd><p>A Boolean.</p></dd><dt><span class="term"><code class="varname">types.int</code></span></dt><dd><p>An integer.</p></dd><dt><span class="term"><code class="varname">types.str</code></span></dt><dd><p>A string.</p></dd><dt><span class="term"><code class="varname">types.lines</code></span></dt><dd><p>A string.  If there are multiple definitions, they are
      concatenated, with newline characters in between.</p></dd><dt><span class="term"><code class="varname">types.path</code></span></dt><dd><p>A path, defined as anything that, when coerced to a
      string, starts with a slash.  This includes derivations.</p></dd><dt><span class="term"><code class="varname">types.listOf</code> <em class="replaceable"><code>t</code></em></span></dt><dd><p>A list of elements of type <em class="replaceable"><code>t</code></em>
      (e.g., <code class="literal">types.listOf types.str</code> is a list of
      strings).  Multiple definitions are concatenated together.</p></dd><dt><span class="term"><code class="varname">types.attrsOf</code> <em class="replaceable"><code>t</code></em></span></dt><dd><p>A set of elements of type <em class="replaceable"><code>t</code></em>
      (e.g., <code class="literal">types.attrsOf types.int</code> is a set of
      name/value pairs, the values being integers).</p></dd><dt><span class="term"><code class="varname">types.nullOr</code> <em class="replaceable"><code>t</code></em></span></dt><dd><p>Either the value <code class="literal">null</code> or something of
      type <em class="replaceable"><code>t</code></em>.</p></dd></dl></div><p>

You can also create new types using the function
<code class="varname">mkOptionType</code>.  See
<code class="filename">lib/types.nix</code> in Nixpkgs for details.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-option-definitions"></a><a xmlns="" href="#sec-option-definitions">22.2. Option Definitions</a></h2></div></div></div><p>Option definitions are generally straight-forward bindings of values to option names, like

</p><pre class="programlisting ">
config = {
  services.httpd.enable = true;
};
</pre><p>

However, sometimes you need to wrap an option definition or set of
option definitions in a <span class="emphasis"><em>property</em></span> to achieve
certain effects:</p><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737316533952"></a><a xmlns="" href="#idm140737316533952">Delaying Conditionals</a></h3></div></div></div><p>If a set of option definitions is conditional on the value of
another option, you may need to use <code class="varname">mkIf</code>.
Consider, for instance:

</p><pre class="programlisting ">
config = if config.services.httpd.enable then {
  environment.systemPackages = [ <em class="replaceable"><code>...</code></em> ];
  <em class="replaceable"><code>...</code></em>
} else {};
</pre><p>

This definition will cause Nix to fail with an “infinite recursion”
error.  Why?  Because the value of
<code class="option">config.services.httpd.enable</code> depends on the value
being constructed here.  After all, you could also write the clearly
circular and contradictory:
</p><pre class="programlisting ">
config = if config.services.httpd.enable then {
  services.httpd.enable = false;
} else {
  services.httpd.enable = true;
};
</pre><p>

The solution is to write:

</p><pre class="programlisting ">
config = mkIf config.services.httpd.enable {
  environment.systemPackages = [ <em class="replaceable"><code>...</code></em> ];
  <em class="replaceable"><code>...</code></em>
};
</pre><p>

The special function <code class="varname">mkIf</code> causes the evaluation of
the conditional to be “pushed down” into the individual definitions,
as if you had written:

</p><pre class="programlisting ">
config = {
  environment.systemPackages = if config.services.httpd.enable then [ <em class="replaceable"><code>...</code></em> ] else [];
  <em class="replaceable"><code>...</code></em>
};
</pre><p>

</p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737316526208"></a><a xmlns="" href="#idm140737316526208">Setting Priorities</a></h3></div></div></div><p>A module can override the definitions of an option in other
modules by setting a <span class="emphasis"><em>priority</em></span>.  All option
definitions that do not have the lowest priority value are discarded.
By default, option definitions have priority 1000.  You can specify an
explicit priority by using <code class="varname">mkOverride</code>, e.g.

</p><pre class="programlisting ">
services.openssh.enable = mkOverride 10 false;
</pre><p>

This definition causes all other definitions with priorities above 10
to be discarded.  The function <code class="varname">mkForce</code> is
equal to <code class="varname">mkOverride 50</code>.</p></div><div class="simplesect"><div class="titlepage"><div><div><h3 class="title"><a id="idm140737316522448"></a><a xmlns="" href="#idm140737316522448">Merging Configurations</a></h3></div></div></div><p>In conjunction with <code class="literal">mkIf</code>, it is sometimes
useful for a module to return multiple sets of option definitions, to
be merged together as if they were declared in separate modules.  This
can be done using <code class="varname">mkMerge</code>:

</p><pre class="programlisting ">
config = mkMerge
  [ # Unconditional stuff.
    { environment.systemPackages = [ <em class="replaceable"><code>...</code></em> ];
    }
    # Conditional stuff.
    (mkIf config.services.bla.enable {
      environment.systemPackages = [ <em class="replaceable"><code>...</code></em> ];
    })
  ];
</pre><p>

</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-building-parts"></a><a xmlns="" href="#sec-building-parts">Chapter 23. Building Specific Parts of NixOS</a></h2></div></div></div><p>With the command <span class="command"><strong>nix-build</strong></span>, you can build
specific parts of your NixOS configuration.  This is done as follows:

</p><pre class="screen ">
$ cd <em class="replaceable"><code>/path/to/nixpkgs/nixos</code></em>
$ nix-build -A config.<em class="replaceable"><code>option</code></em></pre><p>

where <em class="replaceable"><code>option</code></em> is a NixOS option with type
“derivation” (i.e. something that can be built).  Attributes of
interest include:

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term"><code class="varname">system.build.toplevel</code></span></dt><dd><p>The top-level option that builds the entire NixOS system.
      Everything else in your configuration is indirectly pulled in by
      this option.  This is what <span class="command"><strong>nixos-rebuild</strong></span>
      builds and what <code class="filename">/run/current-system</code> points
      to afterwards.</p><p>A shortcut to build this is:

</p><pre class="screen ">
$ nix-build -A system</pre><p>
      </p></dd><dt><span class="term"><code class="varname">system.build.manual.manual</code></span></dt><dd><p>The NixOS manual.</p></dd><dt><span class="term"><code class="varname">system.build.etc</code></span></dt><dd><p>A tree of symlinks that form the static parts of
    <code class="filename">/etc</code>.</p></dd><dt><span class="term"><code class="varname">system.build.initialRamdisk</code>, </span><span class="term"><code class="varname">system.build.kernel</code></span></dt><dd><p>The initial ramdisk and kernel of the system.  This allows
      a quick way to test whether the kernel and the initial ramdisk
      boot correctly, by using QEMU’s <code class="option">-kernel</code> and
      <code class="option">-initrd</code> options:

</p><pre class="screen ">
$ nix-build -A config.system.build.initialRamdisk -o initrd
$ nix-build -A config.system.build.kernel -o kernel
$ qemu-system-x86_64 -kernel ./kernel/bzImage -initrd ./initrd/initrd -hda /dev/null
</pre><p>

      </p></dd><dt><span class="term"><code class="varname">system.build.nixos-rebuild</code>, </span><span class="term"><code class="varname">system.build.nixos-install</code>, </span><span class="term"><code class="varname">system.build.nixos-generate-config</code></span></dt><dd><p>These build the corresponding NixOS commands.</p></dd><dt><span class="term"><code class="varname">systemd.units.<em class="replaceable"><code>unit-name</code></em>.unit</code></span></dt><dd><p>This builds the unit with the specified name.  Note that
      since unit names contain dots
      (e.g. <code class="literal">httpd.service</code>), you need to put them
      between quotes, like this:

</p><pre class="screen ">
$ nix-build -A 'config.systemd.units."httpd.service".unit'
</pre><p>

      You can also test individual units, without rebuilding the whole
      system, by putting them in
      <code class="filename">/run/systemd/system</code>:

</p><pre class="screen ">
$ cp $(nix-build -A 'config.systemd.units."httpd.service".unit')/httpd.service \
    /run/systemd/system/tmp-httpd.service
$ systemctl daemon-reload
$ systemctl start tmp-httpd.service
</pre><p>

      Note that the unit must not have the same name as any unit in
      <code class="filename">/etc/systemd/system</code> since those take
      precedence over <code class="filename">/run/systemd/system</code>.
      That’s why the unit is installed as
      <code class="filename">tmp-httpd.service</code> here.</p></dd></dl></div><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-building-cd"></a><a xmlns="" href="#sec-building-cd">Chapter 24. Building Your Own NixOS CD</a></h2></div></div></div><p>Building a NixOS CD is as easy as configuring your own computer. The
idea is to use another module which will replace
your <code class="filename">configuration.nix</code> to configure the system that
would be installed on the CD.</p><p>Default CD/DVD configurations are available
inside <code class="filename">nixos/modules/installer/cd-dvd</code>.  To build them
you have to set <code class="envar">NIXOS_CONFIG</code> before
running <span class="command"><strong>nix-build</strong></span> to build the ISO.

</p><pre class="screen ">
$ nix-build -A config.system.build.isoImage -I nixos-config=modules/installer/cd-dvd/installation-cd-minimal.nix</pre><p>

</p><p>Before burning your CD/DVD, you can check the content of the image by mounting anywhere like
suggested by the following command:

</p><pre class="screen ">
$ mount -o loop -t iso9660 ./result/iso/cd.iso /mnt/iso</pre><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="ch-testing-installer"></a><a xmlns="" href="#ch-testing-installer">Chapter 25. Testing the Installer</a></h2></div></div></div><p>Building, burning, and booting from an installation CD is rather
tedious, so here is a quick way to see if the installer works
properly:

</p><pre class="screen ">
$ nix-build -A config.system.build.nixos-install
$ mount -t tmpfs none /mnt
$ ./result/bin/nixos-install</pre><p>

To start a login shell in the new NixOS installation in
<code class="filename">/mnt</code>:

</p><pre class="screen ">
$ ./result/bin/nixos-install --chroot
</pre><p>

</p></div></div><div class="part"><div class="titlepage"><div><div><h1 xmlns="" xmlns:d="http://docbook.org/ns/docbook" class="title"><a xmlns="http://www.w3.org/1999/xhtml" id="ch-release-notes"></a><a href="#ch-release-notes">Part V. Release Notes</a></h1></div></div></div><div class="partintro"><div></div><p>This section lists the release notes for each stable version of NixOS
and current unstable revision.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-release-unstable"></a><a xmlns="" href="#sec-release-unstable">Chapter 26. Unstable revision</a></h2></div></div></div><p>In addition to numerous new and upgraded packages, this release has the following highlights:


</p><p>Following new services were added since the last release:


</p><p>When upgrading from a previous release, please be aware of the
following incompatible changes:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Steam now doesn't need root rights to work. Instead of using
<code class="literal">*-steam-chrootenv</code>, you should now just run <code class="literal">steam</code>.
<code class="literal">steamChrootEnv</code> package was renamed to <code class="literal">steam</code>,
and old <code class="literal">steam</code> package -- to <code class="literal">steamOriginal</code>.
</p></li><li class="listitem"><p>CMPlayer has been renamed to bomi upstream. Package <code class="literal">cmplayer</code>
was accordingly renamed to <code class="literal">bomi</code>
</p></li></ul></div><p>
</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-release-14.12"></a><a xmlns="" href="#sec-release-14.12">Chapter 27. Release 14.12 (“Caterpillar”, 2014/12/30)</a></h2></div></div></div><p>In addition to numerous new and upgraded packages, this release has the following highlights:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Systemd has been updated to version 217, which has numerous
<a class="link" href="http://lists.freedesktop.org/archives/systemd-devel/2014-October/024662.html" target="_top">improvements.</a></p></li><li class="listitem"><p><a class="link" href="http://thread.gmane.org/gmane.linux.distributions.nixos/15165" target="_top">
Nix has been updated to 1.8.</a></p></li><li class="listitem"><p>NixOS is now based on Glibc 2.20.</p></li><li class="listitem"><p>KDE has been updated to 4.14.</p></li><li class="listitem"><p>The default Linux kernel has been updated to 3.14.</p></li><li class="listitem"><p>If <code class="option">users.mutableUsers</code> is enabled (the
default), changes made to the declaration of a user or group will be
correctly realised when running <span class="command"><strong>nixos-rebuild</strong></span>. For
instance, removing a user specification from
<code class="filename">configuration.nix</code> will cause the actual user
account to be deleted. If <code class="option">users.mutableUsers</code> is
disabled, it is no longer necessary to specify UIDs or GIDs; if
omitted, they are allocated dynamically.</p></li></ul></div><p>Following new services were added since the last release:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p><code class="literal">atftpd</code></p></li><li class="listitem"><p><code class="literal">bosun</code></p></li><li class="listitem"><p><code class="literal">bspwm</code></p></li><li class="listitem"><p><code class="literal">chronos</code></p></li><li class="listitem"><p><code class="literal">collectd</code></p></li><li class="listitem"><p><code class="literal">consul</code></p></li><li class="listitem"><p><code class="literal">cpuminer-cryptonight</code></p></li><li class="listitem"><p><code class="literal">crashplan</code></p></li><li class="listitem"><p><code class="literal">dnscrypt-proxy</code></p></li><li class="listitem"><p><code class="literal">docker-registry</code></p></li><li class="listitem"><p><code class="literal">docker</code></p></li><li class="listitem"><p><code class="literal">etcd</code></p></li><li class="listitem"><p><code class="literal">fail2ban</code></p></li><li class="listitem"><p><code class="literal">fcgiwrap</code></p></li><li class="listitem"><p><code class="literal">fleet</code></p></li><li class="listitem"><p><code class="literal">fluxbox</code></p></li><li class="listitem"><p><code class="literal">gdm</code></p></li><li class="listitem"><p><code class="literal">geoclue2</code></p></li><li class="listitem"><p><code class="literal">gitlab</code></p></li><li class="listitem"><p><code class="literal">gitolite</code></p></li><li class="listitem"><p><code class="literal">gnome3.gnome-documents</code></p></li><li class="listitem"><p><code class="literal">gnome3.gnome-online-miners</code></p></li><li class="listitem"><p><code class="literal">gnome3.gvfs</code></p></li><li class="listitem"><p><code class="literal">gnome3.seahorse</code></p></li><li class="listitem"><p><code class="literal">hbase</code></p></li><li class="listitem"><p><code class="literal">i2pd</code></p></li><li class="listitem"><p><code class="literal">influxdb</code></p></li><li class="listitem"><p><code class="literal">kubernetes</code></p></li><li class="listitem"><p><code class="literal">liquidsoap</code></p></li><li class="listitem"><p><code class="literal">lxc</code></p></li><li class="listitem"><p><code class="literal">mailpile</code></p></li><li class="listitem"><p><code class="literal">mesos</code></p></li><li class="listitem"><p><code class="literal">mlmmj</code></p></li><li class="listitem"><p><code class="literal">monetdb</code></p></li><li class="listitem"><p><code class="literal">mopidy</code></p></li><li class="listitem"><p><code class="literal">neo4j</code></p></li><li class="listitem"><p><code class="literal">nsd</code></p></li><li class="listitem"><p><code class="literal">openntpd</code></p></li><li class="listitem"><p><code class="literal">opentsdb</code></p></li><li class="listitem"><p><code class="literal">openvswitch</code></p></li><li class="listitem"><p><code class="literal">parallels-guest</code></p></li><li class="listitem"><p><code class="literal">peerflix</code></p></li><li class="listitem"><p><code class="literal">phd</code></p></li><li class="listitem"><p><code class="literal">polipo</code></p></li><li class="listitem"><p><code class="literal">prosody</code></p></li><li class="listitem"><p><code class="literal">radicale</code></p></li><li class="listitem"><p><code class="literal">redmine</code></p></li><li class="listitem"><p><code class="literal">riemann</code></p></li><li class="listitem"><p><code class="literal">scollector</code></p></li><li class="listitem"><p><code class="literal">seeks</code></p></li><li class="listitem"><p><code class="literal">siproxd</code></p></li><li class="listitem"><p><code class="literal">strongswan</code></p></li><li class="listitem"><p><code class="literal">tcsd</code></p></li><li class="listitem"><p><code class="literal">teamspeak3</code></p></li><li class="listitem"><p><code class="literal">thermald</code></p></li><li class="listitem"><p><code class="literal">torque/mrom</code></p></li><li class="listitem"><p><code class="literal">torque/server</code></p></li><li class="listitem"><p><code class="literal">uhub</code></p></li><li class="listitem"><p><code class="literal">unifi</code></p></li><li class="listitem"><p><code class="literal">znc</code></p></li><li class="listitem"><p><code class="literal">zookeeper</code></p></li></ul></div><p>
</p><p>When upgrading from a previous release, please be aware of the
following incompatible changes:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>The default version of Apache httpd is now 2.4. If
you use the <code class="option">extraConfig</code> option to pass literal
Apache configuration text, you may need to update it — see <a class="link" href="http://httpd.apache.org/docs/2.4/upgrading.html" target="_top">Apache’s
documentation</a> for details. If you wish to continue to use
httpd 2.2, add the following line to your NixOS configuration:

</p><pre class="programlisting ">
services.httpd.package = pkgs.apacheHttpd_2_2;
</pre><p>

</p></li><li class="listitem"><p>PHP 5.3 has been removed because it is no longer
supported by the PHP project. A <a class="link" href="http://php.net/migration54" target="_top">migration guide</a> is
available.</p></li><li class="listitem"><p>The host side of a container virtual Ethernet pair
is now called <code class="literal">ve-<em class="replaceable"><code>container-name</code></em></code>
rather than <code class="literal">c-<em class="replaceable"><code>container-name</code></em></code>.</p></li><li class="listitem"><p>GNOME 3.10 support has been dropped. The default GNOME version is now 3.12.</p></li><li class="listitem"><p>VirtualBox has been upgraded to 4.3.20 release. Users
may be required to run <span class="command"><strong>rm -rf /tmp/.vbox*</strong></span>. The line
<code class="literal">imports = [ &lt;nixpkgs/nixos/modules/programs/virtualbox.nix&gt; ]</code> is
no longer necessary, use <code class="literal">services.virtualboxHost.enable =
true</code> instead.
</p><p>Also, hardening mode is now enabled by default, which means that unless you want to use
USB support, you no longer need to be a member of the <code class="literal">vboxusers</code> group.
</p></li><li class="listitem"><p>Chromium has been updated to 39.0.2171.65. <code class="option">enablePepperPDF</code> is now enabled by default.
<code class="literal">chromium*Wrapper</code> packages no longer exist, because upstream removed NSAPI support.
<code class="literal">chromium-stable</code> has been renamed to <code class="literal">chromium</code>.
</p></li><li class="listitem"><p>Python packaging documentation is now part of nixpkgs manual. To override
the python packages available to a custom python you now use <code class="literal">pkgs.pythonFull.buildEnv.override</code>
instead of <code class="literal">pkgs.pythonFull.override</code>.
</p></li><li class="listitem"><p><code class="literal">boot.resumeDevice = "8:6"</code> is no longer supported. Most users will
want to leave it undefined, which takes the swap partitions automatically. There is an evaluation
assertion to ensure that the string starts with a slash.
</p></li><li class="listitem"><p>The system-wide default timezone for NixOS installations
changed from <code class="literal">CET</code> to <code class="literal">UTC</code>. To choose
a different timezone for your system, configure
<code class="literal">time.timeZone</code> in
<code class="literal">configuration.nix</code>. A fairly complete list of possible
values for that setting is available at <a class="link" href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_top">https://en.wikipedia.org/wiki/List_of_tz_database_time_zones</a>.</p></li><li class="listitem"><p>GNU screen has been updated to 4.2.1, which breaks
the ability to connect to sessions created by older versions of
screen.</p></li><li class="listitem"><p>The Intel GPU driver was updated to the 3.x prerelease
version (used by most distributions) and supports DRI3
now.</p></li></ul></div><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-release-14.04"></a><a xmlns="" href="#sec-release-14.04">Chapter 28. Release 14.04 (“Baboon”, 2014/04/30)</a></h2></div></div></div><p>This is the second stable release branch of NixOS.  In addition
to numerous new and upgraded packages and modules, this release has
the following highlights:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Installation on UEFI systems is now supported.  See
  <a class="xref" href="index.html#sec-uefi-installation" title="2.1. UEFI Installation">Section 2.1, “UEFI Installation”</a> for
  details.</p></li><li class="listitem"><p>Systemd has been updated to version 212, which has
  <a class="link" href="http://cgit.freedesktop.org/systemd/systemd/plain/NEWS?id=v212" target="_top">numerous
  improvements</a>. NixOS now automatically starts systemd user
  instances when you log in. You can define global user units through
  the <code class="option">systemd.unit.*</code> options.</p></li><li class="listitem"><p>NixOS is now based on Glibc 2.19 and GCC
  4.8.</p></li><li class="listitem"><p>The default Linux kernel has been updated to
  3.12.</p></li><li class="listitem"><p>KDE has been updated to 4.12.</p></li><li class="listitem"><p>GNOME 3.10 experimental support has been added.</p></li><li class="listitem"><p>Nix has been updated to 1.7 (<a class="link" href="http://nixos.org/nix/manual/#ssec-relnotes-1.7" target="_top">details</a>).</p></li><li class="listitem"><p>NixOS now supports fully declarative management of
  users and groups. If you set <code class="option">users.mutableUsers</code> to
  <code class="literal">false</code>, then the contents of
  <code class="filename">/etc/passwd</code> and <code class="filename">/etc/group</code>
  will be <a class="link" href="https://www.usenix.org/legacy/event/lisa02/tech/full_papers/traugott/traugott_html/" target="_top">congruent</a>
  to your NixOS configuration. For instance, if you remove a user from
  <code class="option">users.extraUsers</code> and run
  <span class="command"><strong>nixos-rebuild</strong></span>, the user account will cease to
  exist. Also, imperative commands for managing users and groups, such
  as <span class="command"><strong>useradd</strong></span>, are no longer available. If
  <code class="option">users.mutableUsers</code> is <code class="literal">true</code> (the
  default), then behaviour is unchanged from NixOS
  13.10.</p></li><li class="listitem"><p>NixOS now has basic container support, meaning you
  can easily run a NixOS instance as a container in a NixOS host
  system. These containers are suitable for testing and
  experimentation but not production use, since they’re not fully
  isolated from the host. See <a class="xref" href="index.html#ch-containers" title="Chapter 19. Container Management">Chapter 19, <em>Container Management</em></a> for
  details.</p></li><li class="listitem"><p>Systemd units provided by packages can now be
  overridden from the NixOS configuration. For instance, if a package
  <code class="literal">foo</code> provides systemd units, you can say:

</p><pre class="programlisting ">
systemd.packages = [ pkgs.foo ];
</pre><p>

  to enable those units. You can then set or override unit options in
  the usual way, e.g.

</p><pre class="programlisting ">
systemd.services.foo.wantedBy = [ "multi-user.target" ];
systemd.services.foo.serviceConfig.MemoryLimit = "512M";
</pre><p>

  </p></li></ul></div><p>

</p><p>When upgrading from a previous release, please be aware of the
following incompatible changes:

</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>Nixpkgs no longer exposes unfree packages by
  default. If your NixOS configuration requires unfree packages from
  Nixpkgs, you need to enable support for them explicitly by setting:

</p><pre class="programlisting ">
nixpkgs.config.allowUnfree = true;
</pre><p>

  Otherwise, you get an error message such as:

</p><pre class="screen ">
error: package ‘nvidia-x11-331.49-3.12.17’ in ‘…/nvidia-x11/default.nix:56’
  has an unfree license, refusing to evaluate
</pre><p>

  </p></li><li class="listitem"><p>The Adobe Flash player is no longer enabled by
  default in the Firefox and Chromium wrappers. To enable it, you must
  set:

</p><pre class="programlisting ">
nixpkgs.config.allowUnfree = true;
nixpkgs.config.firefox.enableAdobeFlash = true; # for Firefox
nixpkgs.config.chromium.enableAdobeFlash = true; # for Chromium
</pre><p>

  </p></li><li class="listitem"><p>The firewall is now enabled by default. If you don’t
  want this, you need to disable it explicitly:

</p><pre class="programlisting ">
networking.firewall.enable = false;
</pre><p>

  </p></li><li class="listitem"><p>The option
  <code class="option">boot.loader.grub.memtest86</code> has been renamed to
  <code class="option">boot.loader.grub.memtest86.enable</code>.</p></li><li class="listitem"><p>The <code class="literal">mysql55</code> service has been
  merged into the <code class="literal">mysql</code> service, which no longer
  sets a default for the option
  <code class="option">services.mysql.package</code>.</p></li><li class="listitem"><p>Package variants are now differentiated by suffixing
  the name, rather than the version. For instance,
  <code class="filename">sqlite-3.8.4.3-interactive</code> is now called
  <code class="filename">sqlite-interactive-3.8.4.3</code>. This ensures that
  <code class="literal">nix-env -i sqlite</code> is unambiguous, and that
  <code class="literal">nix-env -u</code> won’t “upgrade”
  <code class="literal">sqlite</code> to <code class="literal">sqlite-interactive</code>
  or vice versa. Notably, this change affects the Firefox wrapper
  (which provides plugins), as it is now called
  <code class="literal">firefox-wrapper</code>. So when using
  <span class="command"><strong>nix-env</strong></span>, you should do <code class="literal">nix-env -e
  firefox; nix-env -i firefox-wrapper</code> if you want to keep
  using the wrapper. This change does not affect declarative package
  management, since attribute names like
  <code class="literal">pkgs.firefoxWrapper</code> were already
  unambiguous.</p></li><li class="listitem"><p>The symlink <code class="filename">/etc/ca-bundle.crt</code>
  is gone. Programs should instead use the environment variable
  <code class="envar">OPENSSL_X509_CERT_FILE</code> (which points to
  <code class="filename">/etc/ssl/certs/ca-bundle.crt</code>).</p></li></ul></div><p>

</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-release-13.10"></a><a xmlns="" href="#sec-release-13.10">Chapter 29. Release 13.10 (“Aardvark”, 2013/10/31)</a></h2></div></div></div><p>This is the first stable release branch of NixOS.</p></div></div></div></body></html>