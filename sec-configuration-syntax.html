<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Chapter 5. Configuration Syntax</title><link rel="stylesheet" type="text/css" href="style.css" /><link rel="stylesheet" type="text/css" href="highlight/github.css" /><script src="highlight/highlight.pack.js" type="text/javascript"></script><script src="highlight/init.js" type="text/javascript"></script><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="NixOS Manual" /><link rel="up" href="ch-configuration.html" title="Part II. Configuration" /><link rel="prev" href="ch-configuration.html" title="Part II. Configuration" /><link rel="next" href="sec-package-management.html" title="Chapter 6. Package Management" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 5. Configuration Syntax</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch-configuration.html">Prev</a> </td><th width="60%" align="center">Part II. Configuration</th><td width="20%" align="right"> <a accesskey="n" href="sec-package-management.html">Next</a></td></tr></table><hr /></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="sec-configuration-syntax"></a>Chapter 5. Configuration Syntax</h2></div></div></div><div class="toc"><dl class="toc"><dt><span class="section"><a href="sec-configuration-syntax.html#sec-configuration-file">5.1. NixOS Configuration File</a></span></dt><dt><span class="section"><a href="sec-configuration-syntax.html#sec-module-abstractions">5.2. Abstractions</a></span></dt><dt><span class="section"><a href="sec-configuration-syntax.html#sec-modularity">5.3. Modularity</a></span></dt><dt><span class="section"><a href="sec-configuration-syntax.html#sec-nix-syntax-summary">5.4. Syntax Summary</a></span></dt></dl></div><p>The NixOS configuration file
<code class="filename">/etc/nixos/configuration.nix</code> is actually a
<span class="emphasis"><em>Nix expression</em></span>, which is the Nix package
manager’s purely functional language for describing how to build
packages and configurations.  This means you have all the expressive
power of that language at your disposal, including the ability to
abstract over common patterns, which is very useful when managing
complex systems.  The syntax and semantics of the Nix language are
fully described in the <a class="link" href="http://nixos.org/nix/manual/#chap-writing-nix-expressions" target="_top">Nix
manual</a>, but here we give a short overview of the most important
constructs useful in NixOS configuration files.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-configuration-file"></a>5.1. NixOS Configuration File</h2></div></div></div><p>The NixOS configuration file generally looks like this:

</p><pre class="programlisting nix">
{ config, pkgs, ... }:

{ <em class="replaceable"><code>option definitions</code></em>
}
</pre><p>

The first line (<code class="literal">{ config, pkgs, ... }:</code>) denotes
that this is actually a function that takes at least the two arguments
 <code class="varname">config</code> and <code class="varname">pkgs</code>.  (These are
explained later.)  The function returns a <span class="emphasis"><em>set</em></span> of
option definitions (<code class="literal">{ <em class="replaceable"><code>...</code></em> }</code>).  These definitions have the
form <code class="literal"><em class="replaceable"><code>name</code></em> =
<em class="replaceable"><code>value</code></em></code>, where
<em class="replaceable"><code>name</code></em> is the name of an option and
<em class="replaceable"><code>value</code></em> is its value.  For example,

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ services.httpd.enable = true;
  services.httpd.adminAddr = "alice@example.org";
  services.httpd.documentRoot = "/webroot";
}
</pre><p>

defines a configuration with three option definitions that together
enable the Apache HTTP Server with <code class="filename">/webroot</code> as
the document root.</p><p>Sets can be nested, and in fact dots in option names are
shorthand for defining a set containing another set.  For instance,
<code class="option">services.httpd.enable</code> defines a set named
<code class="varname">services</code> that contains a set named
<code class="varname">httpd</code>, which in turn contains an option definition
named <code class="varname">enable</code> with value <code class="literal">true</code>.
This means that the example above can also be written as:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ services = {
    httpd = {
      enable = true;
      adminAddr = "alice@example.org";
      documentRoot = "/webroot";
    };
  };
}
</pre><p>

which may be more convenient if you have lots of option definitions
that share the same prefix (such as
<code class="literal">services.httpd</code>).</p><p>NixOS checks your option definitions for correctness.  For
instance, if you try to define an option that doesn’t exist (that is,
doesn’t have a corresponding <span class="emphasis"><em>option declaration</em></span>),
<span class="command"><strong>nixos-rebuild</strong></span> will give an error like:
</p><pre class="screen ">
The option 'services.httpd.enable' defined in '/etc/nixos/configuration.nix' does not exist.
</pre><p>
Likewise, values in option definitions must have a correct type.  For
instance, <code class="option">services.httpd.enable</code> must be a Boolean
(<code class="literal">true</code> or <code class="literal">false</code>).  Trying to give
it a value of another type, such as a string, will cause an error:
</p><pre class="screen ">
The option value 'services.httpd.enable' in '/etc/nixos/configuration.nix' is not a boolean.
</pre><p>

</p><p>Options have various types of values.  The most important are:

</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Strings</span></dt><dd><p>Strings are enclosed in double quotes, e.g.

</p><pre class="programlisting ">
networking.hostName = "dexter";
</pre><p>

      Special characters can be escaped by prefixing them with a
      backslash (e.g. <code class="literal">\"</code>).</p><p>Multi-line strings can be enclosed in <span class="emphasis"><em>double
      single quotes</em></span>, e.g.

</p><pre class="programlisting nix">
networking.extraHosts =
  ''
    127.0.0.2 other-localhost
    10.0.0.1 server
  '';
</pre><p>

      The main difference is that preceding whitespace is
      automatically stripped from each line, and that characters like
      <code class="literal">"</code> and <code class="literal">\</code> are not special
      (making it more convenient for including things like shell
      code).</p></dd><dt><span class="term">Booleans</span></dt><dd><p>These can be <code class="literal">true</code> or
      <code class="literal">false</code>, e.g.

</p><pre class="programlisting ">
networking.firewall.enable = true;
networking.firewall.allowPing = false;
</pre><p>
      </p></dd><dt><span class="term">Integers</span></dt><dd><p>For example,

</p><pre class="programlisting nix">
boot.kernel.sysctl."net.ipv4.tcp_keepalive_time" = 60;
</pre><p>

      (Note that here the attribute name
      <code class="literal">net.ipv4.tcp_keepalive_time</code> is enclosed in
      quotes to prevent it from being interpreted as a set named
      <code class="literal">net</code> containing a set named
      <code class="literal">ipv4</code>, and so on.  This is because it’s not a
      NixOS option but the literal name of a Linux kernel
      setting.)</p></dd><dt><span class="term">Sets</span></dt><dd><p>Sets were introduced above.  They are name/value pairs
      enclosed in braces, as in the option definition

</p><pre class="programlisting ">
fileSystems."/boot" =
  { device = "/dev/sda1";
    fsType = "ext4";
    options = "rw,data=ordered,relatime";
  };
</pre><p>
      </p></dd><dt><span class="term">Lists</span></dt><dd><p>The important thing to note about lists is that list
      elements are separated by whitespace, like this:

</p><pre class="programlisting ">
boot.kernelModules = [ "fuse" "kvm-intel" "coretemp" ];
</pre><p>

      List elements can be any other type, e.g. sets:

</p><pre class="programlisting ">
swapDevices = [ { device = "/dev/disk/by-label/swap"; } ];
</pre><p>
      </p></dd><dt><span class="term">Packages</span></dt><dd><p>Usually, the packages you need are already part of the Nix
      Packages collection, which is a set that can be accessed through
      the function argument <code class="varname">pkgs</code>.  Typical uses:

</p><pre class="programlisting ">
environment.systemPackages =
  [ pkgs.thunderbird
    pkgs.emacs
  ];

postgresql.package = pkgs.postgresql90;
</pre><p>

      The latter option definition changes the default PostgreSQL
      package used by NixOS’s PostgreSQL service to 9.0.  For more
      information on packages, including how to add new ones, see
      <a class="xref" href="sec-package-management.html#sec-custom-packages" title="6.1.2. Adding Custom Packages">Section 6.1.2, “Adding Custom Packages”</a>.</p></dd></dl></div><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-module-abstractions"></a>5.2. Abstractions</h2></div></div></div><p>If you find yourself repeating yourself over and over, it’s time
to abstract.  Take, for instance, this Apache HTTP Server configuration:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    [ { hostName = "example.org";
        documentRoot = "/webroot";
        adminAddr = "alice@example.org";
        enableUserDir = true;
      }
      { hostName = "example.org";
        documentRoot = "/webroot";
        adminAddr = "alice@example.org";
        enableUserDir = true;
        enableSSL = true;
        sslServerCert = "/root/ssl-example-org.crt";
        sslServerKey = "/root/ssl-example-org.key";
      }
    ];
}
</pre><p>

It defines two virtual hosts with nearly identical configuration; the
only difference is that the second one has SSL enabled.  To prevent
this duplication, we can use a <code class="literal">let</code>:

</p><pre class="programlisting ">
let
  exampleOrgCommon =
    { hostName = "example.org";
      documentRoot = "/webroot";
      adminAddr = "alice@example.org";
      enableUserDir = true;
    };
in
{
  services.httpd.virtualHosts =
    [ exampleOrgCommon
      (exampleOrgCommon // {
        enableSSL = true;
        sslServerCert = "/root/ssl-example-org.crt";
        sslServerKey = "/root/ssl-example-org.key";
      })
    ];
}
</pre><p>

The <code class="literal">let exampleOrgCommon =
<em class="replaceable"><code>...</code></em></code> defines a variable named
<code class="literal">exampleOrgCommon</code>.  The <code class="literal">//</code>
operator merges two attribute sets, so the configuration of the second
virtual host is the set <code class="literal">exampleOrgCommon</code> extended
with the SSL options.</p><p>You can write a <code class="literal">let</code> wherever an expression is
allowed.  Thus, you also could have written:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let exampleOrgCommon = <em class="replaceable"><code>...</code></em>; in
    [ exampleOrgCommon
      (exampleOrgCommon // { <em class="replaceable"><code>...</code></em> })
    ];
}
</pre><p>

but not <code class="literal">{ let exampleOrgCommon =
<em class="replaceable"><code>...</code></em>; in <em class="replaceable"><code>...</code></em>;
}</code> since attributes (as opposed to attribute values) are not
expressions.</p><p><span class="emphasis"><em>Functions</em></span> provide another method of
abstraction.  For instance, suppose that we want to generate lots of
different virtual hosts, all with identical configuration except for
the host name.  This can be done as follows:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let
      makeVirtualHost = name:
        { hostName = name;
          documentRoot = "/webroot";
          adminAddr = "alice@example.org";
        };
    in
      [ (makeVirtualHost "example.org")
        (makeVirtualHost "example.com")
        (makeVirtualHost "example.gov")
        (makeVirtualHost "example.nl")
      ];
}
</pre><p>

Here, <code class="varname">makeVirtualHost</code> is a function that takes a
single argument <code class="literal">name</code> and returns the configuration
for a virtual host.  That function is then called for several names to
produce the list of virtual host configurations.</p><p>We can further improve on this by using the function
<code class="varname">map</code>, which applies another function to every
element in a list:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let
      makeVirtualHost = <em class="replaceable"><code>...</code></em>;
    in map makeVirtualHost
      [ "example.org" "example.com" "example.gov" "example.nl" ];
}
</pre><p>

(The function <code class="literal">map</code> is called a
<span class="emphasis"><em>higher-order function</em></span> because it takes another
function as an argument.)</p><p>What if you need more than one argument, for instance, if we
want to use a different <code class="literal">documentRoot</code> for each
virtual host?  Then we can make <code class="varname">makeVirtualHost</code> a
function that takes a <span class="emphasis"><em>set</em></span> as its argument, like this:

</p><pre class="programlisting ">
{
  services.httpd.virtualHosts =
    let
      makeVirtualHost = { name, root }:
        { hostName = name;
          documentRoot = root;
          adminAddr = "alice@example.org";
        };
    in map makeVirtualHost
      [ { name = "example.org"; root = "/sites/example.org"; }
        { name = "example.com"; root = "/sites/example.com"; }
        { name = "example.gov"; root = "/sites/example.gov"; }
        { name = "example.nl"; root = "/sites/example.nl"; }
      ];
}
</pre><p>

But in this case (where every root is a subdirectory of
<code class="filename">/sites</code> named after the virtual host), it would
have been shorter to define <code class="varname">makeVirtualHost</code> as
</p><pre class="programlisting ">
makeVirtualHost = name:
  { hostName = name;
    documentRoot = "/sites/${name}";
    adminAddr = "alice@example.org";
  };
</pre><p>

Here, the construct
<code class="literal">${<em class="replaceable"><code>...</code></em>}</code> allows the result
of an expression to be spliced into a string.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-modularity"></a>5.3. Modularity</h2></div></div></div><p>The NixOS configuration mechanism is modular.  If your
<code class="filename">configuration.nix</code> becomes too big, you can split
it into multiple files.  Likewise, if you have multiple NixOS
configurations (e.g. for different computers) with some commonality,
you can move the common configuration into a shared file.</p><p>Modules have exactly the same syntax as
<code class="filename">configuration.nix</code>.  In fact,
<code class="filename">configuration.nix</code> is itself a module.  You can
use other modules by including them from
<code class="filename">configuration.nix</code>, e.g.:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ imports = [ ./vpn.nix ./kde.nix ];
  services.httpd.enable = true;
  environment.systemPackages = [ pkgs.emacs ];
  <em class="replaceable"><code>...</code></em>
}
</pre><p>

Here, we include two modules from the same directory,
<code class="filename">vpn.nix</code> and <code class="filename">kde.nix</code>.  The
latter might look like this:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ services.xserver.enable = true;
  services.xserver.displayManager.kdm.enable = true;
  services.xserver.desktopManager.kde4.enable = true;
  environment.systemPackages = [ pkgs.kde4.kscreensaver ];
}
</pre><p>

Note that both <code class="filename">configuration.nix</code> and
<code class="filename">kde.nix</code> define the option
<code class="option">environment.systemPackages</code>.  When multiple modules
define an option, NixOS will try to <span class="emphasis"><em>merge</em></span> the
definitions.  In the case of
<code class="option">environment.systemPackages</code>, that’s easy: the lists of
packages can simply be concatenated.  The value in
<code class="filename">configuration.nix</code> is merged last, so for
list-type options, it will appear at the end of the merged list. If
you want it to appear first, you can use <code class="varname">mkBefore</code>:

</p><pre class="programlisting ">
boot.kernelModules = mkBefore [ "kvm-intel" ];
</pre><p>

This causes the <code class="literal">kvm-intel</code> kernel module to be
loaded before any other kernel modules.</p><p>For other types of options, a merge may not be possible. For
instance, if two modules define
<code class="option">services.httpd.adminAddr</code>,
<span class="command"><strong>nixos-rebuild</strong></span> will give an error:

</p><pre class="screen ">
The unique option 'services.httpd.adminAddr' is defined multiple times, in '/etc/nixos/httpd.nix' and '/etc/nixos/configuration.nix'.
</pre><p>

When that happens, it’s possible to force one definition take
precedence over the others:

</p><pre class="programlisting ">
services.httpd.adminAddr = pkgs.lib.mkForce "bob@example.org";
</pre><p>

</p><p>When using multiple modules, you may need to access
configuration values defined in other modules.  This is what the
<code class="varname">config</code> function argument is for: it contains the
complete, merged system configuration.  That is,
<code class="varname">config</code> is the result of combining the
configurations returned by every module<a href="#ftn.idm140737316911232" class="footnote" id="idm140737316911232"><sup class="footnote">[1]</sup></a>.  For example, here is a module that adds
some packages to <code class="option">environment.systemPackages</code> only if
<code class="option">services.xserver.enable</code> is set to
<code class="literal">true</code> somewhere else:

</p><pre class="programlisting ">
{ config, pkgs, ... }:

{ environment.systemPackages =
    if config.services.xserver.enable then
      [ pkgs.firefox
        pkgs.thunderbird
      ]
    else
      [ ];
}
</pre><p>

</p><p>With multiple modules, it may not be obvious what the final
value of a configuration option is.  The command
<code class="option">nixos-option</code> allows you to find out:

</p><pre class="screen ">
$ nixos-option services.xserver.enable
true

$ nixos-option boot.kernelModules
[ "tun" "ipv6" "loop" <em class="replaceable"><code>...</code></em> ]
</pre><p>

Interactive exploration of the configuration is possible using
<span class="command"><strong><a class="command" href="https://github.com/edolstra/nix-repl" target="_top">nix-repl</a></strong></span>,
a read-eval-print loop for Nix expressions.  It’s not installed by
default; run <code class="literal">nix-env -i nix-repl</code> to get it.  A
typical use:

</p><pre class="screen ">
$ nix-repl '&lt;nixos&gt;'

nix-repl&gt; config.networking.hostName
"mandark"

nix-repl&gt; map (x: x.hostName) config.services.httpd.virtualHosts
[ "example.org" "example.gov" ]
</pre><p>

</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="sec-nix-syntax-summary"></a>5.4. Syntax Summary</h2></div></div></div><p>Below is a summary of the most important syntactic constructs in
the Nix expression language.  It’s not complete.  In particular, there
are many other built-in functions.  See the <a class="link" href="http://nixos.org/nix/manual/#chap-writing-nix-expressions" target="_top">Nix
manual</a> for the rest.</p><div class="informaltable"><table border="0"><colgroup><col class="c1" /><col class="c2" /></colgroup><thead><tr><th>Example</th><th>Description</th></tr></thead><tbody><tr><td colspan="2"><span class="emphasis"><em>Basic values</em></span></td></tr><tr><td><code class="literal">"Hello world"</code></td><td>A string</td></tr><tr><td><code class="literal">"${pkgs.bash}/bin/sh"</code></td><td>A string containing an expression (expands to <code class="literal">"/nix/store/<em class="replaceable"><code>hash</code></em>-bash-<em class="replaceable"><code>version</code></em>/bin/sh"</code>)</td></tr><tr><td><code class="literal">true</code>, <code class="literal">false</code></td><td>Booleans</td></tr><tr><td><code class="literal">123</code></td><td>An integer</td></tr><tr><td><code class="literal">./foo.png</code></td><td>A path (relative to the containing Nix expression)</td></tr><tr><td colspan="2"><span class="emphasis"><em>Compound values</em></span></td></tr><tr><td><code class="literal">{ x = 1; y = 2; }</code></td><td>An set with attributes names <code class="literal">x</code> and <code class="literal">y</code></td></tr><tr><td><code class="literal">{ foo.bar = 1; }</code></td><td>A nested set, equivalent to <code class="literal">{ foo = { bar = 1; }; }</code></td></tr><tr><td><code class="literal">rec { x = "foo"; y = x + "bar"; }</code></td><td>A recursive set, equivalent to <code class="literal">{ x = "foo"; y = "foobar"; }</code></td></tr><tr><td><code class="literal">[ "foo" "bar" ]</code></td><td>A list with two elements</td></tr><tr><td colspan="2"><span class="emphasis"><em>Operators</em></span></td></tr><tr><td><code class="literal">"foo" + "bar"</code></td><td>String concatenation</td></tr><tr><td><code class="literal">1 + 2</code></td><td>Integer addition</td></tr><tr><td><code class="literal">"foo" == "f" + "oo"</code></td><td>Equality test (evaluates to <code class="literal">true</code>)</td></tr><tr><td><code class="literal">"foo" != "bar"</code></td><td>Inequality test (evaluates to <code class="literal">true</code>)</td></tr><tr><td><code class="literal">!true</code></td><td>Boolean negation</td></tr><tr><td><code class="literal">{ x = 1; y = 2; }.x</code></td><td>Attribute selection (evaluates to <code class="literal">1</code>)</td></tr><tr><td><code class="literal">{ x = 1; y = 2; }.z or 3</code></td><td>Attribute selection with default (evaluates to <code class="literal">3</code>)</td></tr><tr><td><code class="literal">{ x = 1; y = 2; } // { z = 3; }</code></td><td>Merge two sets (attributes in the right-hand set taking precedence)</td></tr><tr><td colspan="2"><span class="emphasis"><em>Control structures</em></span></td></tr><tr><td><code class="literal">if 1 + 1 == 2 then "yes!" else "no!"</code></td><td>Conditional expression</td></tr><tr><td><code class="literal">assert 1 + 1 == 2; "yes!"</code></td><td>Assertion check (evaluates to <code class="literal">"yes!"</code>)</td></tr><tr><td><code class="literal">let x = "foo"; y = "bar"; in x + y</code></td><td>Variable definition</td></tr><tr><td><code class="literal">with pkgs.lib; head [ 1 2 3 ]</code></td><td>Add all attributes from the given set to the scope
        (evaluates to <code class="literal">1</code>)</td></tr><tr><td colspan="2"><span class="emphasis"><em>Functions (lambdas)</em></span></td></tr><tr><td><code class="literal">x: x + 1</code></td><td>A function that expects an integer and returns it increased by 1</td></tr><tr><td><code class="literal">(x: x + 1) 100</code></td><td>A function call (evaluates to 101)</td></tr><tr><td><code class="literal">let inc = x: x + 1; in inc (inc (inc 100))</code></td><td>A function bound to a variable and subsequently called by name (evaluates to 103)</td></tr><tr><td><code class="literal">{ x, y }: x + y</code></td><td>A function that expects a set with required attributes
        <code class="literal">x</code> and <code class="literal">y</code> and concatenates
        them</td></tr><tr><td><code class="literal">{ x, y ? "bar" }: x + y</code></td><td>A function that expects a set with required attribute
        <code class="literal">x</code> and optional <code class="literal">y</code>, using
        <code class="literal">"bar"</code> as default value for
        <code class="literal">y</code></td></tr><tr><td><code class="literal">{ x, y, ... }: x + y</code></td><td>A function that expects a set with required attributes
        <code class="literal">x</code> and <code class="literal">y</code> and ignores any
        other attributes</td></tr><tr><td><code class="literal">{ x, y } @ args: x + y</code></td><td>A function that expects a set with required attributes
        <code class="literal">x</code> and <code class="literal">y</code>, and binds the
        whole set to <code class="literal">args</code></td></tr><tr><td colspan="2"><span class="emphasis"><em>Built-in functions</em></span></td></tr><tr><td><code class="literal">import ./foo.nix</code></td><td>Load and return Nix expression in given file</td></tr><tr><td><code class="literal">map (x: x + x) [ 1 2 3 ]</code></td><td>Apply a function to every element of a list (evaluates to <code class="literal">[ 2 4 6 ]</code>)</td></tr></tbody></table></div></div><div class="footnotes"><br /><hr style="width:100; text-align:left;margin-left: 0" /><div id="ftn.idm140737316911232" class="footnote"><p><a href="#idm140737316911232" class="para"><sup class="para">[1] </sup></a>If you’re
wondering how it’s possible that the (indirect)
<span class="emphasis"><em>result</em></span> of a function is passed as an
<span class="emphasis"><em>input</em></span> to that same function: that’s because Nix
is a “lazy” language — it only computes values when they are needed.
This works as long as no individual configuration value depends on
itself.</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch-configuration.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="ch-configuration.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="sec-package-management.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Part II. Configuration </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> Chapter 6. Package Management</td></tr></table></div></body></html>